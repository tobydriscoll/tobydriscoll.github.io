

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Euler’s method &#8212; Fundamentals of Numerical Computation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/proof.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .secondtoggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"float": ["\\mathbb{F}"], "real": ["\\mathbb{R}"], "complex": ["\\mathbb{C}"], "nat": ["\\mathbb{N}"], "integer": ["\\mathbb{Z}"], "rmn{([^}]*)}{([^}]*)}": ["\\mathbb{R}^{#1 \\times #2}", 2], "dd{([^}]*)}{([^}]*)}": ["\\frac{d #1}{d #2}", 2], "ddd{([^}]*)}{([^}]*)}": ["\\frac{d^2 #1}{d #2^2}", 2], "pp{([^}]*)}{([^}]*)}": ["\\frac{\\partial #1}{\\partial #2}", 2], "ppp{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2], "ppdd{([^}]*)}{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2 \\partial #3}", 3], "norm{([^}]*)}": ["\\| #1 \\|", 1], "twonorm{([^}]*)}": ["\\| #1 \\|_2", 1], "onenorm{([^}]*)}": ["\\| #1 \\|_1", 1], "infnorm{([^}]*)}": ["\\| #1 \\|_\\infty", 1], "anynorm{([^}]*)}{([^}]*)}": ["\\| #1 \\|_#2", 2], "innerprod{([^}]*)}{([^}]*)}": ["\\langle #1,#2 \\rangle", 2], "pr{([^}]*)}": ["^{(#1)}", 1], "kron{([^}]*)}{([^}]*)}": ["#1 \\otimes #2", 2], "eye{([^}]*)}": ["\\mathbf{e}_#1", 1], "meye": ["\\mathbf{I}"], "Qhat": ["\\hat{\\mathbf{Q}}"], "Rhat": ["\\hat{\\mathbf{R}}"], "bfalpha": ["\\mathbf{alpha}"], "bfdelta": ["\\mathbf{delta}"], "bfzero": ["\\boldsymbol{0}"], "macheps": ["\\epsilon_\\text{mach}"], "fl": ["\\operatorname{fl}"], "diag": ["\\operatorname{diag}"], "ign": ["\\operatorname{sign}"], "Re": ["\\operatorname{Re}"], "Im": ["\\operatorname{Im}"], "ee": ["\\times 10^"], "lnorm": ["\\|"], "rnorm": ["\\|"], "floor": ["\\lfloor#1\\rfloor", 1]}}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Systems of differential equations" href="systems.html" />
    <link rel="prev" title="Basics of IVPs" href="basics.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Fundamentals of Numerical Computation</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="../frontmatter.html">Front matter</a>
  </li>
  <li class="">
    <a href="../intro/overview.html">Introduction</a>
  </li>
  <li class="">
    <a href="../linsys/overview.html">Square linear systems</a>
  </li>
  <li class="">
    <a href="../leastsq/overview.html">Overdetermined linear systems</a>
  </li>
  <li class="">
    <a href="../nonlineqn/overview.html">Roots of nonlinear equations</a>
  </li>
  <li class="">
    <a href="../localapprox/overview.html">Piecewise interpolation</a>
  </li>
  <li class="active">
    <a href="overview.html">Initial-value problems for ODEs</a>
  <ul class="nav sidenav_l2">
    <li class="">
      <a href="basics.html">Basics of IVPs</a>
    </li>
    <li class="active">
      <a href="">Euler’s method</a>
    </li>
    <li class="">
      <a href="systems.html">Systems of differential equations</a>
    </li>
    <li class="">
      <a href="rk.html">Runge–Kutta methods</a>
    </li>
    <li class="">
      <a href="adaptive.html">Adaptive Runge–Kutta</a>
    </li>
    <li class="">
      <a href="multistep.html">Multistep methods</a>
    </li>
    <li class="">
      <a href="implicit.html">Implementation of multistep methods</a>
    </li>
    <li class="">
      <a href="zerostability.html">Zero-stability of multistep methods</a>
    </li>
  </ul>
  </li>
  <li class="">
    <a href="../appendix/linear-algebra.html">Review: Linear algebra</a>
  </li>
  <li class="">
    <a href="../appendix/demos.html">All demo notebooks</a>
  </li>
  <li class="">
    <a href="../genindex.html">Index</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="../_sources/ivp/euler.md.txt"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.md</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Edit this page -->
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#local-truncation-error" class="nav-link">Local truncation error</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#convergence" class="nav-link">Convergence</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#exercises" class="nav-link">Exercises</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="euler-s-method">
<h1>Euler’s method<a class="headerlink" href="#euler-s-method" title="Permalink to this headline">¶</a></h1>
<p id="index-0">Let a first-order initial-value problem be given in the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  u'(t) &amp;= f\bigl(t,u(t)\bigr), \qquad a \le t \le b,\\
  u(a)&amp; =u_0.
\end{split}\end{split}\]</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>A numerical method represents the solution of an IVP by its values at a finite collection of times.</p>
</div>
<p>We represent a numerical solution of an IVP by its values at a finite collection of nodes, which for now we require to be equally spaced:</p>
<div class="math notranslate nohighlight">
\[t_i = a + ih, \qquad h=\frac{b-a}{n}, \qquad i=0,\ldots,n.\]</div>
<p>The number <span class="math notranslate nohighlight">\(h\)</span> is called the <a class="reference internal" href="overview.html#term-step-size"><span class="xref std std-term">step size</span></a>.</p>
<p>Because we don’t get exactly correct values of the solution at the nodes, we need to take some care with the notation. From now on we let <span class="math notranslate nohighlight">\(\hat{u}(t)\)</span> denote the exact solution of the IVP. The approximate value at <span class="math notranslate nohighlight">\(t_i\)</span> computed at the nodes by our numerical methods will be denoted by <span class="math notranslate nohighlight">\(u_i\approx \hat{u}(t_i)\)</span>. Because we are given the initial value <span class="math notranslate nohighlight">\(u(a)=u_0\)</span> exactly, there is no need to distinguish whether we mean <span class="math notranslate nohighlight">\(u_0\)</span> as the exact or the numerical solution.</p>
<p>Consider a piecewise linear interpolant to the (as yet unknown) values <span class="math notranslate nohighlight">\(u_0,u_1,\ldots\)</span>, <span class="math notranslate nohighlight">\(u_n\)</span>. Its derivative is piecewise constant with values</p>
<div class="math notranslate nohighlight">
\[\frac{u_{i+1} - u_{i}}{t_{i+1}-t_i} = \frac{u_{i+1}-u_i}{h}, \qquad t_i &lt; t &lt; t_{i+1},\]</div>
<p>where <span class="math notranslate nohighlight">\(i=0,\ldots,n-1\)</span>. We can connect this derivative to the differential equation by following the model of <span class="math notranslate nohighlight">\(u'=f(t,u)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{u_{i+1}-u_i}{h} = f(t_i,u_i), \qquad i=0,\ldots,n-1.\]</div>
<p>We could also view the left-hand side as a forward-difference approximation to <span class="math notranslate nohighlight">\(u'(t)\)</span> at <span class="math notranslate nohighlight">\(t=t_i\)</span>. Either way, we can rearrange to get</p>
<div class="math notranslate nohighlight" id="equation-euler1">
<span class="eqno">(168)<a class="headerlink" href="#equation-euler1" title="Permalink to this equation">¶</a></span>\[  u_{i+1}=u_i + h f(t_i,u_i), \qquad i=0,\ldots,n-1.\]</div>
<p>Together with the starting value <span class="math notranslate nohighlight">\(u_0\)</span> from the initial condition, this formula defines an iteration known as <a class="reference internal" href="overview.html#term-euler-s-method"><span class="xref std std-term">Euler’s method</span></a>.  It is an explicit method, meaning that the answer at the new time level is explicitly given in terms of the older time level(s).</p>
<p>A basic implementation of Euler’s method is shown in <a class="reference internal" href="#function-euler"><span class="std std-ref">euler</span></a>. It expects the problem to be specified in the form of a function <span class="math notranslate nohighlight">\(f\)</span> of two arguments, an interval defining the time domain, and an initial condition. It also requires the number of intervals <span class="math notranslate nohighlight">\(n\)</span> defined by the nodes (or equivalently, the number of steps in the iteration). The output of <a class="reference internal" href="#function-euler"><span class="std std-ref">euler</span></a> is a vector of the nodes and a vector of approximate solution values at those nodes.</p>
<div class="proof proof-type-function" id="id1">
<span id="function-euler"></span>
    <div class="proof-title">
        <span class="proof-type">Function 61</span>
        
            <span class="proof-title-name">(euler)</span>
        
    </div><div class="proof-content">
<p><strong>Euler’s method for an initial-value problem.</strong></p>
<div class="highlight-julia notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="s">&quot;&quot;&quot;</span>
<span class="s">    euler(ivp,n)</span>

<span class="s">Apply Euler&#39;s method to solve the given IVP using `n` time steps. Returns a vector of times and a vector of solution values.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span> <span class="n">euler</span><span class="p">(</span><span class="n">ivp</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="c"># Time discretization.</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">ivp</span><span class="o">.</span><span class="n">tspan</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="mi">0</span><span class="o">:</span><span class="n">n</span> <span class="p">]</span>

    <span class="c"># Initial condition and output setup.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="n">float</span><span class="p">(</span><span class="n">ivp</span><span class="o">.</span><span class="n">u0</span><span class="p">),</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># The time stepping iteration.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="kp">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">ivp</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">ivp</span><span class="o">.</span><span class="n">p</span><span class="p">,</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span><span class="n">u</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
</div></div><div class="proof proof-type-demo">

    <div class="proof-title">
        <span class="proof-type">Demo </span>
        
    </div><div class="proof-content">
<p><a class="reference internal" href="demos/euler-converge.html"><span class="doc">Convergence of Euler’s method</span></a></p>
</div></div><div class="section" id="local-truncation-error">
<h2>Local truncation error<a class="headerlink" href="#local-truncation-error" title="Permalink to this headline">¶</a></h2>
<p>It should be clear that Euler’s method cannot get the exact solution unless it happens to be piecewise linear. More generally, suppose that an oracle has granted us the exact solution at <span class="math notranslate nohighlight">\(t=t_i\)</span>, so that <span class="math notranslate nohighlight">\(u_i=\hat{u}(t_i)\)</span>. How would we then fare in obtaining <span class="math notranslate nohighlight">\(u_{i+1}\)</span> as an approximation to <span class="math notranslate nohighlight">\(\hat{u}(t_{i+1})\)</span>? The answer is revealed through a Taylor series:</p>
<div class="math notranslate nohighlight" id="equation-eulerlte">
<span class="eqno">(169)<a class="headerlink" href="#equation-eulerlte" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{split}
  \hat{u}(t_{i+1}) - \bigl[ u_i + hf(t_i,u_i) \bigr]
 &amp;=  \hat{u}(t_{i+1}) - \bigl[ \hat{u}(t_i) + hf\bigl(t_i,\hat{u}(t_i)\bigr) \bigr] \\
 &amp;= \bigl[ \hat{u}(t_i) + h \hat{u}'(t_i) + \tfrac{1}{2}h^2 \hat{u}''(t_i) + \cdots \bigr] \\
 &amp;\qquad\quad  - \bigl[ \hat{u}(t_i) + h\hat{u}'(t_i) \bigr] \notag \\
  &amp;= \tfrac{1}{2}h^2 \hat{u}''(t_i) + O(h^3),
\end{split}\end{split}\]</div>
<p>where used the fact that <span class="math notranslate nohighlight">\(\hat{u}\)</span> satisfies the differential equation.</p>
<p>We formalize this calculation as follows. Euler’s method may be written in the abstract form</p>
<div class="math notranslate nohighlight" id="equation-onestepode">
<span class="eqno">(170)<a class="headerlink" href="#equation-onestepode" title="Permalink to this equation">¶</a></span>\[\mathbf{u}_{i+1} = u_i + h\phi(t_i,u_i,h), \qquad i=0,\ldots,n-1,\]</div>
<span class="target" id="index-1"></span><p id="index-2">which we call a general <strong>one-step method</strong>. Euler’s method is the particular case <span class="math notranslate nohighlight">\(\phi(t,u,h) = f(t,u)\)</span>, but we will see other one-step methods in future sections. When we substitute the exact solution at <span class="math notranslate nohighlight">\(t=t_i\)</span>, calculate the resulting error at <span class="math notranslate nohighlight">\(t_{i+1}\)</span>, and divide by <span class="math notranslate nohighlight">\(h\)</span>, we get a quantity called the <a class="reference internal" href="overview.html#term-local-truncation-error"><span class="xref std std-term">local truncation error</span></a> (LTE) of the one-step formula. In the general one-step formula this is</p>
<div class="math notranslate nohighlight" id="equation-onesteplte">
<span class="eqno">(171)<a class="headerlink" href="#equation-onesteplte" title="Permalink to this equation">¶</a></span>\[  \tau_{i+1}(h) := \frac{\hat{u}(t_{i+1})-\hat{u}(t_i)}{h} - \phi\bigl(t_i,\hat{u}(t_i),h\bigr).\]</div>
<p>Compared to <a class="reference internal" href="#equation-eulerlte">(169)</a> there is an extra division by <span class="math notranslate nohighlight">\(h\)</span>, which we explain below. First, though, note that in the limit <span class="math notranslate nohighlight">\(h\rightarrow 0\)</span> in <a class="reference internal" href="#equation-onesteplte">(171)</a>, we obtain</p>
<div class="math notranslate nohighlight">
\[  \hat{u}'(t_i) - \phi(t_i,\hat{u}(t_i),0),\]</div>
<p>which through the ODE is the same as</p>
<div class="math notranslate nohighlight">
\[  f(t_i,\hat{u}(t_i)) - \phi(t_i,\hat{u}(t_i),0).\]</div>
<p>It seems reasonable to expect the LTE to vanish as the step size goes to zero for any ODE, which implies that <span class="math notranslate nohighlight">\(\phi(t,u,0)=f(t,u)\)</span> for any function <span class="math notranslate nohighlight">\(u\)</span> whatsoever. This condition on the one-step formula is called <strong>consistency</strong>. It is trivially true for Euler’s method.</p>
</div>
<div class="section" id="convergence">
<h2>Convergence<a class="headerlink" href="#convergence" title="Permalink to this headline">¶</a></h2>
<p>The local truncation error measures the effect of a single step of the numerical method. It’s straightforward to calculate from the formula, but the practical quantity of interest is the <a class="reference internal" href="overview.html#term-global-error"><span class="xref std std-term">global error</span></a>, <span class="math notranslate nohighlight">\(\hat{u}(t_i) - u_i\)</span>, over the entire time interval. By <a class="reference internal" href="#equation-onesteplte">(171)</a>, <span class="math notranslate nohighlight">\(h\tau_{i+1}(h)\)</span> describes how much error is made by taking a single step, starting from the exact value. If there were no other sources of or effects on the error, we would add up all of those local errors to get the global error.</p>
<p>To reach the time <span class="math notranslate nohighlight">\(t=b\)</span> from <span class="math notranslate nohighlight">\(t=a\)</span> with step size <span class="math notranslate nohighlight">\(h\)</span>, we need to take <span class="math notranslate nohighlight">\(n=(b-a)/h\)</span> steps. If we want to reach, say, <span class="math notranslate nohighlight">\(t=(a+b)/2\)</span>, then we would have to take <span class="math notranslate nohighlight">\(n/2\)</span> steps, and so on. The point is that to reach any fixed time in the interval, we need to take <span class="math notranslate nohighlight">\(O(n)=O(h^{-1})\)</span> steps. That is why we express the error made in one step as <span class="math notranslate nohighlight">\(h\tau_{i+1}(h)\)</span>, with that extra factor of <span class="math notranslate nohighlight">\(h\)</span> taken out. By this reasoning, for instance, the LTE of Euler computed in <a class="reference internal" href="#equation-eulerlte">(169)</a> implies a global error that is <span class="math notranslate nohighlight">\(O(h)\)</span>.</p>
<p>However, global error is not just a simple sum of local errors. As each step causes a perturbation of the solution, we jump from one solution curve to a new one. The new curve will have its own trajectory, i.e., the error will propagate through the ODE (see <a class="reference internal" href="demos/basics-cond.html"><span class="doc">Conditioning of IVPs</span></a>). This phenomenon is precisely the subject of <a class="reference internal" href="basics.html#theorem-depic"><span class="std std-ref">IC dependence</span></a>: jumping to a different solution curve incurs a condition number at time <span class="math notranslate nohighlight">\(t&gt;t_i\)</span> of <span class="math notranslate nohighlight">\(e^{L(t-t_i)}\)</span>, which is constant at fixed time as <span class="math notranslate nohighlight">\(h\to 0\)</span>.</p>
<p>The following theorem puts our observations above on a rigorous footing.</p>
<div class="proof proof-type-theorem" id="id2">
<span id="theorem-onestepgte"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 62</span>
        
    </div><div class="proof-content">
<p>Suppose that the unit local truncation error of the one-step method <a class="reference internal" href="#equation-onestepode">(170)</a> satisfies</p>
<div class="math notranslate nohighlight" id="equation-ultebound">
<span class="eqno">(172)<a class="headerlink" href="#equation-ultebound" title="Permalink to this equation">¶</a></span>\[  |\tau_{i+1}(h)| \le C h^p\]</div>
<p>and that</p>
<div class="math notranslate nohighlight" id="equation-gtelip">
<span class="eqno">(173)<a class="headerlink" href="#equation-gtelip" title="Permalink to this equation">¶</a></span>\[\left| \frac{\partial \phi}{\partial u} \right| \le L\]</div>
<p>for all <span class="math notranslate nohighlight">\(t\in[a,b]\)</span>, all <span class="math notranslate nohighlight">\(u\)</span>, and all <span class="math notranslate nohighlight">\(h&gt;0\)</span>. Then the global error satisfies</p>
<div class="math notranslate nohighlight" id="equation-gtebound">
<span class="eqno">(174)<a class="headerlink" href="#equation-gtebound" title="Permalink to this equation">¶</a></span>\[|\hat{u}(t_i) - u_i| \le \frac{Ch^p}{L} \left[ e^{L(t_i-a)} - 1
\right] = O(h^p),\]</div>
<p>as <span class="math notranslate nohighlight">\(h\rightarrow 0\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Define the global error sequence <span class="math notranslate nohighlight">\(E_i=\hat{u}(t_i)-u_i\)</span>. Using <a class="reference internal" href="#equation-onestepode">(170)</a>, we obtain</p>
<div class="math notranslate nohighlight">
\[  E_{i+1} - E_i = \hat{u}(t_{i+1}) - \hat{u}(t_i) - ( \mathbf{u}_{i+1} - u_i ) =
  \hat{u}(t_{i+1}) - \hat{u}(t_i) - h\phi(t_i,u_i,h),\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[  E_{i+1} = E_i + \hat{u}(t_{i+1}) - \hat{u}(t_i) - h\phi(t_i,\hat{u}(t_i),h) +
  h[\phi(t_i,\hat{u}(t_i),h)- \phi(t_i,u_i,h)].\]</div>
<p>We apply the triangle inequality,  <a class="reference internal" href="#equation-onesteplte">(171)</a>, and <a class="reference internal" href="#equation-ultebound">(172)</a> to find</p>
<div class="math notranslate nohighlight">
\[  |E_{i+1}| \le |E_i| + Ch^{p+1} + h \left| \phi(t_i,\hat{u}(t_i),h)- \phi(t_i,u_i,h)\right|.\]</div>
<p>The Fundamental Theorem of Calculus implies that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  \left| \phi(t_i,\hat{u}(t_i),h)- \phi(t_i,u_i,h)\right|
      &amp; = \left|  \int_{u_i}^{\hat{u}(t_i)} \frac{\partial \phi}{\partial u} \,du  \right|\\
    &amp; \le  \int_{u_i}^{\hat{u}(t_i)} \left|\frac{\partial \phi}{\partial u}\right| \,du \\
    &amp;= \le L | \hat{u}(t_i)-u_i| = L\, |E_i|.
\end{split}\end{split}\]</div>
<p>Thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  |E_{i+1}| &amp;\le Ch^{p+1} + (1 + hL) |E_i| \\
  &amp;\le Ch^{p+1} + (1 + hL) \bigl[ Ch^{p+1} + (1 + hL) |E_{i-1}|
  \bigr]\\
  &amp;\;\vdots \\
  &amp;\le Ch^{p+1} \left[ 1 + (1+hL) + (1+hL)^2 + \cdots + (1+hL)^i
  \right].
\end{split}\end{split}\]</div>
<p>To get the last line we applied the inequality recursively until reaching <span class="math notranslate nohighlight">\(E_0\)</span>, which is zero. Replacing <span class="math notranslate nohighlight">\(i+1\)</span> by <span class="math notranslate nohighlight">\(i\)</span> and simplifying the geometric sum, we get</p>
<div class="math notranslate nohighlight">
\[  |E_i| \le Ch^{p+1}\frac{(1+hL)^i - 1}{(1+hL)-1} = \frac{Ch^p}{L}
  \left[ (1+hL)^i - 1 \right].\]</div>
<p>We observe that <span class="math notranslate nohighlight">\(1+x \le e^x\)</span> for <span class="math notranslate nohighlight">\(x\ge 0\)</span> (see <a class="reference internal" href="#problem-expdominate"><span class="std std-ref">this exercise</span></a>). Hence <span class="math notranslate nohighlight">\((1+hL)^i \le e^{i h L}\)</span>, which completes the proof.</p>
</div></div><div class="margin sidebar">
<p class="sidebar-title"></p>
<p>The local truncation error of a one-step method has the same order of accuracy as the global error.</p>
</div>
<p id="index-3">The theorem justifies a general definition of <a class="reference internal" href="../localapprox/overview.html#term-order-of-accuracy"><span class="xref std std-term">order of accuracy</span></a> as the leading exponent of <span class="math notranslate nohighlight">\(h\)</span> in <span class="math notranslate nohighlight">\(\tau_{i+i}(h)\)</span>: the local truncation error of a one-step method has the same order of accuracy as the global error. This agrees with the first-order convergence we observed experimentally for Euler in <a class="reference internal" href="demos/euler-converge.html"><span class="doc">Convergence of Euler’s method</span></a>. Note, however, that the <span class="math notranslate nohighlight">\(O(h^p)\)</span> convergence hides a leading constant that grows exponentially in time. When the time interval is bounded as <span class="math notranslate nohighlight">\(h\to 0\)</span>, this does not interfere with the conclusion, but the behavior as <span class="math notranslate nohighlight">\(t\to\infty\)</span> contains no such guarantee.</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol>
<li><p>✍️ Do two steps of Euler’s method for the following problems using the given step size <span class="math notranslate nohighlight">\(h\)</span>. Then, compute the error using the given exact solution.</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(u' = -2t u, \ u(0) = 2;\ h=0.1;\ \hat{u}(t) = 2e^{-t^2}\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(u' = u + t, \ u(0) = 2;\ h=0.2;\ \hat{u}(t) = -1-t+3e^t\)</span></p>
<p><strong>(c)</strong> <span class="math notranslate nohighlight">\(t u' + u = 1, \ u(1) = 6, \ h = 0.25;\ \hat{u}(t) = 1+5/t\)</span></p>
<p><strong>(d)</strong> <span class="math notranslate nohighlight">\(u' - 2u(1-u) = 0, \ u(0) = 1/2, \ h = 0.25; \ \hat{u}(t) = 1/(1 + e^{-2t})\)</span></p>
</li>
<li><p>⌨️ For each IVP, solve the problem using <a class="reference internal" href="#function-euler"><span class="std std-ref">euler</span></a>. (i) Plot the solution for <span class="math notranslate nohighlight">\(n=320\)</span>. (ii) For <span class="math notranslate nohighlight">\(n=10\cdot2^k\)</span>, <span class="math notranslate nohighlight">\(k=2,3,\ldots,10\)</span>, compute the error at the final time and make a log–log convergence plot, including a reference line for first-order convergence.</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(u' = -2t u, \ 0 \le t \le 2, \ u(0) = 2;\  \hat{u}(t) = 2e^{-t^2}\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(u' = u + t, \ 0 \le t \le 1, \ u(0) = 2;\  \hat{u}(t) = -1-t+3e^t\)</span></p>
<p><strong>(c)</strong> <span class="math notranslate nohighlight">\((1+t^3)uu' = t^2,\ 0 \le xt \le 3, \ u(0) =1;\ \hat{u}(t) = [1+(2/3)\ln (1+xt^3)]^{1/2}\)</span></p>
<p><strong>(d)</strong> <span class="math notranslate nohighlight">\(u' - 2u(1-u) = 0, \ 0 \le t \le 2, \ u(0) = 1/2; \ \hat{u}(t) = 1/(1 + e^{-2t})\)</span></p>
<p><strong>(e)</strong> <span class="math notranslate nohighlight">\(v' - (1+x^2) v = 0, \ 1 \le x \le 3, \ v(1) = 1, \ \hat{v}(x) = e^{-(\pi/4)+\arctan(x)}\)</span></p>
<p><strong>(f)</strong> <span class="math notranslate nohighlight">\(v' + (1+x^2) v^2 = 0, \ 0 \le x \le 2, \ v(0) = 2, \ \hat{v}(x) = 1/(0.5+\arctan(x))\)</span></p>
<p><strong>(g)</strong> <span class="math notranslate nohighlight">\(u' = 2(1+t)(1+u^2), \ 0 \le t \le 0.5, \ u(0) = 0,  \ \hat{u}(t) = \tan(2t + t^2)\)</span></p>
</li>
<li><p>⌨️ For each IVP, compute the error at the final time in the numerical solution obtained by Euler’s method with <span class="math notranslate nohighlight">\(n=32\)</span>. Compare this error to the bound <a class="reference internal" href="#equation-gtebound">(174)</a> with the smallest allowable value of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(y' = -2t y, \ 0 \le t \le 2, \ y(0) = 2;\ \hat{y}(t) = 2e^{-t^2}\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(y' = y + t, \ 0 \le t \le 1, \ y(0) = 2;\ \hat{y}(t) = -1-t+3e^t\)</span></p>
</li>
<li><p>✍️ Here is an alternative to Euler’s method:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  v_{i+1} &amp;= u_i + h f(t_i,u_i)\\
  u_{i+1} &amp;= u_i + hf(t_{i}+h,v_{i+1}).
\end{split}\end{split}\]</div>
<p><strong>(a)</strong> Write out the method explicitly in the general one-step form <a class="reference internal" href="#equation-onestepode">(170)</a> (i.e., clarify what <span class="math notranslate nohighlight">\(\phi\)</span> is for this method).</p>
<p><strong>(b)</strong> Show that the method is consistent.</p>
</li>
<li><p>✍️ Consider the problem <span class="math notranslate nohighlight">\(u'=ku\)</span>, <span class="math notranslate nohighlight">\(u(0)=1\)</span> for constant <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(t&gt;0\)</span>.</p>
<p><strong>(a)</strong> Find an explicit formula in terms of <span class="math notranslate nohighlight">\(h\)</span>, <span class="math notranslate nohighlight">\(k\)</span>, and <span class="math notranslate nohighlight">\(i\)</span> for the Euler solution <span class="math notranslate nohighlight">\(u_i\)</span> at <span class="math notranslate nohighlight">\(t=ih\)</span>.</p>
<p><strong>(b)</strong> Find values of <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(h\)</span> such that <span class="math notranslate nohighlight">\(|u_i|\to\infty\)</span> as <span class="math notranslate nohighlight">\(i\to\infty\)</span> while the exact solution <span class="math notranslate nohighlight">\(\hat{u}(t)\)</span> is bounded as <span class="math notranslate nohighlight">\(t\to\infty\)</span>.</p>
</li>
<li id="problem-expdominate"><p>✍️ Prove the fact, used in the proof of the <a class="reference internal" href="#theorem-onestepgte"><span class="std std-ref">convergence theorem</span></a>`, that <span class="math notranslate nohighlight">\(1+x\le e^x\)</span> for all <span class="math notranslate nohighlight">\(x\ge 0\)</span>.</p>
</li>
<li><p>✍️ Suppose that the error in making a step is also subject to roundoff error <span class="math notranslate nohighlight">\(\epsilon_{i+1}\)</span>, so that <span class="math notranslate nohighlight">\(\tau_{i+1}(h) = Ch^p+\epsilon_{i+1} h^{-1}\)</span>; assume that <span class="math notranslate nohighlight">\(|\epsilon_{i+1}| \le \epsilon\)</span> is the largest roundoff error in the computation and that the initial condition is known exactly. Generalize the <a class="reference internal" href="#theorem-onestepgte"><span class="std std-ref">convergence theorem</span></a> for this case.</p>
</li>
</ol>
</div>
</div>


              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="basics.html" title="previous page">Basics of IVPs</a>
    <a class='right-next' id="next-link" href="systems.html" title="next page">Systems of differential equations</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tobin A. Driscoll and Richard J. Braun<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>