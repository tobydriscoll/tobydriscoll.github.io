

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>&lt;no title&gt; &#8212; Fundamentals of Numerical Computation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/proof.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .secondtoggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"float": ["\\mathbb{F}"], "real": ["\\mathbb{R}"], "complex": ["\\mathbb{C}"], "nat": ["\\mathbb{N}"], "integer": ["\\mathbb{Z}"], "rmn{([^}]*)}{([^}]*)}": ["\\mathbb{R}^{#1 \\times #2}", 2], "dd{([^}]*)}{([^}]*)}": ["\\frac{d #1}{d #2}", 2], "ddd{([^}]*)}{([^}]*)}": ["\\frac{d^2 #1}{d #2^2}", 2], "pp{([^}]*)}{([^}]*)}": ["\\frac{\\partial #1}{\\partial #2}", 2], "ppp{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2], "ppdd{([^}]*)}{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2 \\partial #3}", 3], "norm{([^}]*)}": ["\\| #1 \\|", 1], "twonorm{([^}]*)}": ["\\| #1 \\|_2", 1], "onenorm{([^}]*)}": ["\\| #1 \\|_1", 1], "infnorm{([^}]*)}": ["\\| #1 \\|_\\infty", 1], "anynorm{([^}]*)}{([^}]*)}": ["\\| #1 \\|_#2", 2], "innerprod{([^}]*)}{([^}]*)}": ["\\langle #1,#2 \\rangle", 2], "pr{([^}]*)}": ["^{(#1)}", 1], "kron{([^}]*)}{([^}]*)}": ["#1 \\otimes #2", 2], "eye{([^}]*)}": ["\\mathbf{e}_#1", 1], "meye": ["\\mathbf{I}"], "Qhat": ["\\hat{\\mathbf{Q}}"], "Rhat": ["\\hat{\\mathbf{R}}"], "bfalpha": ["\\mathbf{alpha}"], "bfdelta": ["\\mathbf{delta}"], "bfzero": ["\\boldsymbol{0}"], "macheps": ["\\epsilon_\\text{mach}"], "fl": ["\\operatorname{fl}"], "diag": ["\\operatorname{diag}"], "ign": ["\\operatorname{sign}"], "Re": ["\\operatorname{Re}"], "Im": ["\\operatorname{Im}"], "ee": ["\\times 10^"], "lnorm": ["\\|"], "rnorm": ["\\|"], "floor": ["\\lfloor#1\\rfloor", 1]}}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Fundamentals of Numerical Computation</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="../frontmatter.html">Front matter</a>
  </li>
  <li class="">
    <a href="../intro/overview.html">Introduction</a>
  </li>
  <li class="">
    <a href="../linsys/overview.html">Square linear systems</a>
  </li>
  <li class="">
    <a href="../leastsq/overview.html">Overdetermined linear systems</a>
  </li>
  <li class="">
    <a href="../nonlineqn/overview.html">Roots of nonlinear equations</a>
  </li>
  <li class="">
    <a href="overview.html">Piecewise interpolation</a>
  </li>
  <li class="">
    <a href="../ivp/overview.html">Initial-value problems for ODEs</a>
  </li>
  <li class="">
    <a href="../appendix/linear-algebra.html">Review: Linear algebra</a>
  </li>
  <li class="">
    <a href="../appendix/demos.html">All demo notebooks</a>
  </li>
  <li class="">
    <a href="../genindex.html">Index</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="../_sources/localapprox/B-splines.md.txt"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.md</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Edit this page -->
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}%  :label: bspline1
%  B(x;s,t) =
%  \begin{cases}
%    1,&amp; \text{if $s \le x &lt; t$}, \\
%    0, &amp; \text{otherwise}.
%  \end{cases}
%```\end{split}\\%This function is also known as a characteristic or \emph{indicator
%function}, as it simply indicates whether $x$ is in the interval
%$[s,t)$. It is piecewise constant, with jumps in value at $x=s$ and
%$x=t$.
%
%Close examination (and a look back at {eq}`hatfun`) should
%convince you that we can write a piecewise linear hat function as
%
```{math}
%  H_k(x) = \frac{x-s_{k}}{s_{k+1}-s_{k}} B(x;s_{k},s_{k+1}) +
%  \frac{s_{k+2}-x}{s_{k+2}-s_{k+1}} B(x;s_{k+1},s_{k+2}),
%```\\%where $s_k=t_{k-1}$.
%Specifically, this function is
%piecewise linear, nonzero only in two adjacent intervals
%$[s_{k},s_{k+1}]$ and $[s_{k+1},s_{k+2}]$, and continuous everywhere, with jumps
%in the first derivative at $s_{k}$, $s_{k+1}$, and $s_{k+2}$. We now
%rename this function $B(x;s_{k},s_{k+1},s_{k+2})$, and in this
%context we will call $s_{k},s_{k+1},s_{k+2}$ **knots**.
%
%It turns out that we can combine two of these three-knot, piecewise linear functions to
%get a four-knot, piecewise quadratic function, and so on. In general,
%we define a **B-spline of order $\mathbf{r**$} via the formula
%
```{math}
%  :label: bspline
%  B(x;s_1,s_2,\ldots,s_r) = \frac{x-s_1}{s_{r-1}-s_1} B(x;s_1,\ldots,s_{r-1}) +
%  \frac{s_{r}-x}{s_{r}-s_{2}} B(x;s_2,\ldots,s_r).
%```\\\begin{split}%We assume that the knots satisfy $s_1&lt;s_2&lt;\cdots &lt; s_r$. (However, in
%{ref}`prob-bsplines-coincidentknots` you are shown how to cope with
%knots that coincide, i.e., have multiplicity greater than one.)
%
%The formula {eq}`bspline` defines a B-spline on $r$ knots in terms
%of two B-splines on consecutive sets of $r-1$ knots. Each of these is in turn defined
%in terms of two B-splines on $r-2$ knots, but two of these shorter
%B-splines are the same function, so there are only three unique B-splines
%of $r-2$ knots:
%$B(x;s_1,\ldots,s_{r-2})$, $B(x;s_2,\ldots,s_{r-1})$, and $B(x;s_3,\ldots,s_r)$.
%The process continues recursively until one reaches $r-1$ unique B-splines on
%pairs of consecutive knots and can plug in {eq}`bspline1` for them.
%
%
````{proof:example}
%  \label{exa:Bsplinehand}
%  Let's find an explicit formula for $B(x;0,1,2,4)$ for $1 &lt; x &lt; 2$.
%  It's easiest to start at the bottom level, from the indicator
%  functions, and work upward. For $x$ in the given interval, the
%  indicators $B(x;0,1)$ and $B(x;2,4)$ are zero, and $B(x;1,2)\equiv
%  1$. There are two consecutive triples of knots:
%  
```{math}
\begin{split}
%    B(x;0,1,2) &amp;= \frac{x-0}{1-0} \cdot 0 + \frac{2-x}{2-1}\cdot 1 =
%    (2-x),\\
%    B(x;1,2,4) &amp;= \frac{x-1}{2-1} \cdot 1 + \frac{4-x}{4-2}\cdot 0 =
%    (x-1).
%  \end{split}\end{split}\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}%    B(x;,0,1,2,4) = \frac{x-0}{2-0} \cdot (2-x)
%    + \frac{4-x}{4-1}\cdot(x-1) = \frac{4}{5} - \frac{(5x-8)^2}{30}.
%  ```\\%````\\%
%\begin{function}
%  (function-Bspline)=\\````{proof:function} Bspline
****\\```{code-block} julia
:lineno-start: 1
\end{aligned}\end{align} \]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%  \caption{Evaluation of a B-spline.}
%\end{function}
%
%In {ref}`function-Bspline` we show an algorithm for evaluating a
%B-spline using {eq}`bspline1` and {eq}`bspline`
%directly. This is our first example of a recursive function---one that
%calls itself. The first line of the function is like a contract: given
%inputs that satisfy certain conditions, it returns an output
%satisfying stated conditions. In this case, given value(s) of $x$ and
%a vector of knots, {ref}`function-Bspline` returns the value of the
%B-spline. So in lines~16 and~17, where the recursive calls occur, we
%may conclude that &quot;B1&quot; and &quot;B2&quot; contain the values of
%B-splines on shorter sequences of knots. If we originally call the
%function on a vector of 4 knots, it makes two calls on vectors of 3
%knots, each of which makes two calls using vectors of 2 knots, which
%execute line~13. Only then can the calls with 3 knots be completed,
%and then finally the original call with 4 knots is completed. The
%recursive form of implementation is very simple, but (as is often the
%case) not efficient; in {ref}`prob-bsplines-implementation` you are
%asked to create a better one.
%
%One final note about line~13: it uses the fact
%that the logical operators, such as &quot;&gt;=&quot; and &quot;\&amp;&quot;,
%return values that can be converted to numerical 1 (true) and 0
%(false) values using &quot;double&quot;.
%
%
````{proof:example}
%  ````{admonition}
{doc}`demos/bsplinegraph`
</pre></div>
</div>
<div class="proof proof-type-theorem" id="id1">

    <div class="proof-title">
        <span class="proof-type">Theorem </span>
        
    </div><div class="proof-content">
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}%  :label: interpbasis
%  p(x) = \sum_{k=1}^n c_k \phi_k(x),
%```\\\begin{split}%for coefficients $c_k$ to be determined by $n+1$ interpolation conditions at the nodes.
%
%If we let the knots be the same as the nodes, then there are only $n-3$ consecutive 5-tuples to create candidate basis functions for {eq}`interpbasis`. This leaves us four short of the number needed to give us enough coefficients to match the interpolation conditions. We can borrow the trick of fictitious nodes from piecewise linear interpolation. We need four new knots in total, so a candidate knot set is $t_{-2},t_{-1},t_0,\ldots,t_n,t_{n+1},t_{n+2}$, where the first and last two nodes are located arbitrarily on their respective sides of the interval $[t_0,t_n]$.
%
%For a subtle reason to be considered in {ref}`prob-bsplines-notaknot`, however, this collection of knots will not produce what we want. Instead, we need the knot sequence
%\begin{gather*}
%  s_1=t_{-3},\,s_2=t_{-2},\,s_3=t_{-1},\,s_4=t_0,\\
%  s_5=t_2,\, s_6=t_3,\, \ldots,\, s_n=t_{n-3},\ s_{n+1}=t_{n-2},\\
%  s_{n+2}=t_n,\, s_{n+3}=t_{n+1},\, s_{n+4}=t_{n+2},\, s_{n+5}=t_{n+3}.
%\end{gather*}
%We left out nodes $t_1$ and $t_{n-1}$ and have *three* fictitious
%nodes on each side. Because $t_1$ and $t_{n-1}$ are not knots, there
%is no discontinuity in $p'''$ there. This arrangement is called a
%**not-a-knot spline**.
%
%There are $n+5$ not-a-knot knots, and thus $n+1$ consecutive
%5-tuples. These define third-order B-splines as the basis functions
%$\phi_k$ in {eq}`interpbasis`. What remains is to solve for the
%interpolation coefficients $c_k$ in that formula. By evaluation of $p$
%at each of the interpolation nodes (*not* the not-a-knot knots),
%we get a linear system of equations:
%
```{math}
%  :label: interpbasissys
%  \begin{bmatrix}
%    \phi_{1}(t_0) &amp; \phi_{2}(t_0) &amp; \cdots &amp; \phi_{n+1}(t_0) \\
%    \phi_{1}(t_1) &amp; \phi_{2}(t_1) &amp; \cdots &amp; \phi_{n+1}(t_1) \\
%    \vdots &amp; \vdots &amp; &amp; \vdots\\
%    \phi_{1}(t_n) &amp; \phi_{2}(t_n) &amp; \cdots &amp; \phi_{n+1}(t_n)
%  \end{bmatrix}
%  \begin{bmatrix}
%    c_1 \\ c_2 \\ \vdots \\ c_{n+1}
%  \end{bmatrix}
%  =
%  \begin{bmatrix}
%    y_0 \\ y_1 \\ \vdots \\ y_{n}
%  \end{bmatrix}.
%```\end{split}\\%The basis functions have limited support intervals. This makes many of
%the matrix entries zero. Specifically,
%
```{math}
%  B(s_j;s_i,\ldots,s_{i+4}) = 0, \qquad j&lt;i \text{ or } j&gt;i+4.
%```\\%Consequently, the matrix in {eq}`interpbasissys` has only five
%nonzero entries per row, and upper bandwidth and lower bandwidth both
%equal to two. Because the matrix has constant bandwidth 5 for any value
%of $n$, only $O(n)$ operations are needed to find the coefficients.
%{ref}`function-spinterp` demonstrates a basic implementation.
%\begin{function}
%  (function-spinterp)=\\````{proof:function} spinterp
****\\```{code-block} julia
:lineno-start: 1
&quot;&quot;&quot;
    spinterp(t,y)\\Create a cubic not-a-knot spline interpolating function for data values in `y` given at nodes
in `t`.
&quot;&quot;&quot;
function spinterp(t,y)\\    n = length(t)-1
    h = diff(t)         # differences of all adjacent pairs\\    # Preliminary definitions.
    Z = zeros(n,n);
    In = I(n);  E = In[1:n-1,:];
    J = diagm(0=&gt;ones(n),1=&gt;-ones(n-1))
    H = diagm(0=&gt;h)\\    # Left endpoint interpolation:
    AL = [ In Z Z Z ]
    vL = y[1:n]\\    # Right endpoint interpolation:
    AR = [ In H H^2 H^3 ];
    vR = y[2:n+1]\\    # Continuity of first derivative:
    A1 = E*[ Z J 2*H 3*H^2 ]
    v1 = zeros(n-1)\\    # Continuity of second derivative:
    A2 = E*[ Z Z J 3*H ]
    v2 = zeros(n-1)\\    # Not-a-knot conditions:
    nakL = [ zeros(1,3*n) [1 -1 zeros(1,n-2)] ]
    nakR = [ zeros(1,3*n) [zeros(1,n-2) 1 -1] ]\\    # Assemble and solve the full system.
    A = [ AL; AR; A1; A2; nakL; nakR ]
    v = [ vL; vR; v1; v2; 0; 0 ]
    z = A\v\\    # Break the coefficients into separate vectors.
    rows = 1:n
    a = z[rows]
    b = z[n.+rows];  c = z[2*n.+rows];  d = z[3*n.+rows]
    S = [ Polynomial([a[k],b[k],c[k],d[k]]) for k = 1:n ]
    # This function evaluates the spline when called with a value for x.
    function evaluate(x)
        k = findfirst(&#64;. x&lt;t)   # one greater than interval x belongs to
        k==1 &amp;&amp; return NaN
        if isnothing(k)
            return x==t[end] ? y[end] : NaN
        end
        return S[k-1](x-t[k-1])
    end
    return evaluate
end\end{aligned}\end{align} \]</div>
</div></div><div class="proof proof-type-example" id="id2">

    <div class="proof-title">
        <span class="proof-type">Example </span>
        
    </div><div class="proof-content">
<p><span class="xref std std-doc">demos/bsplineinterp</span></p>
</div></div><div class="proof proof-type-example" id="id3">

    <div class="proof-title">
        <span class="proof-type">Example </span>
        
    </div><div class="proof-content">
<div class="proof proof-type-example" id="id4">

    <div class="proof-title">
        <span class="proof-type">Example </span>
        
    </div><div class="proof-content">
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}%  x(0),\quad x(1),\quad y(0),\quad y(1),\quad \frac{d y}{d x}(0),\quad \frac{d y}{d x}(1)
%```\\%are given.
%
%Note that the two cubics have eight parameters between
%them, but only six conditions for the curve are specified. The root of
%the problem is that
%
```{math}
%  \frac{d y}{d x} = \frac{dy/dt}{dx/dt}
%```\\%and so if $x'$ and $y'$ are scaled by the same constant, the curve's slope
%is unchanged.  It turns out that this &quot;problem&quot; is actually a
%strength. The scaling factors in $x'$ and $y'$ affect how closely the
%interpolant follows the tangent line at the node. Graphically, this is
%communicated via the use of **control points**, as illustrated in
%Figure~\ref{fig:bezier}. The direction from a node to its control
%point gives the slope at the end, while the distance from the node to
%the control point sets the scaling factor in the derivatives of $x(t)$
%and $y(t)$ and influences how strongly the tangency persists.
%
%\begin{figure}[tb]
%  \centering
%  \psfrag{r0}[t][t]{$\mathbf{r}_0$}
%  \psfrag{r3}[t][t]{$\mathbf{r}_3$}
%  \psfrag{r1}[b][b]{$\mathbf{r}_1$}
%  \psfrag{r2}[b][b]{$\mathbf{r}_2$}
%  \includegraphics[width=\textwidth]{bezier}
%  \caption{Cubic B\'ezier curves. In both cases the end values and
%    slopes are the same. When the distance from node to control point is
%    increased, the relative weight of the tangency condition is
%    increased.}
%  \label{fig:bezier}
%\end{figure}
%
%At this point it becomes more convenient to switch to a vector
%notation. Let $\mathbf{r}(t)$ be the vector $[x(t),y(t)]^T$, defined for
%$0\le t \le 1$. The end nodes will be denoted $\mathbf{r}_0$ and $\mathbf{r}_3$,
%and their control points are be $\mathbf{r}_1$ and $\mathbf{r}_2$, respectively.
%We want the curve to satisfy
%
```{math}
%  \mathbf{r}(0) = \mathbf{r}_0, \qquad \mathbf{r}(1) = \mathbf{r}_3, \qquad \mathbf{r}'(0) =
%  3(\mathbf{r}_1-\mathbf{r}_0), \qquad \mathbf{r}'(1) = 3(\mathbf{r}_3-\mathbf{r}_2).
%```\\%(The seemingly extraneous factors of $3$ in $\mathbf{r}'$ make the numbers
%come out cleaner in general formulas.) It is straightforward to show that
%
```{math}
%  :label: bezier
%  \mathbf{r}(t) = (1-t)^3 \mathbf{r}_0 + 3t(1-t)^2\mathbf{r}_1
%  + 3t^2(1-t) \mathbf{r}_2 + t^3 \mathbf{r}_3
%```\\%is the unique cubic function satisfying these conditions.
%Equation {eq}`bezier` describes a \textbf{cubic B\'ezier
%curve}.
%
%
%In \matlab\ we might implement a simple cubic B\'ezier curve as shown
%in Function~\ref{fun:bezier}.
%\begin{function}
%  \Mfile{interpolation/Bezier.m}
%  \caption{Cubic B\'ezier curve evaluation.}
%  \label{fun:bezier}
%\end{function}
%The two columns of &quot;node&quot; hold the endpoints and the two
%columns of &quot;control&quot; are their associated control points. The
%vector &quot;t&quot; should have parameter values between 0 and 1. The
%last line is a little subtle, making use of vector outer products to
%create a matrix of results in which each column is a point on the
%curve for one value in &quot;t&quot;. One convenient aspect of
%&quot;bezier&quot; is that it can be used exactly as written for a
%B\'ezier curve in three or more dimensions, as determined implicitly
%by the input.
%
%In practice, one could have many nodes and evaluate a different
%B\'ezier curve piecewise between each pair of neighboring nodes.
%Interior nodes would have a control point on each side. Note that each
%piece of the curve is completely determined by local data; conversely,
%moving a node affects only the segments of the curve passing through
%it.  B\'ezier interpolation is often implemented interactively, with
%the computer guessing the initial control points and the user moving
%them and the nodes to get the desired shape.
%
%
````{proof:example}
%\label{exa:bezier}
%In this example, we consider making a stylized ``V&quot; using three
%B\'ezier curves put together.  Certainly it is easiest to
%graphically input data for nodes and control points and subsequently
%manipulate them. For this example we only need 4 nodes (and control
%points), and in the absence of graphical input, one could draw the
%desired letter on a grid to estimate the node and control point
%locations.  The following code snippet shows the nodes and control
%points that draw the letter.  Note that Function~\ref{fun:bezier} is
%called 3 times and the results are concatenated prior to plotting;
%the control points are plotted as squares. The result is shown in Figure~\ref{fig:exabezier}.
%\begin{verbatim}
%% each column is a node or control point
%nodes = [-0.3,1.3;0.1,2.5;-0.3,-1.8;0.8,2.6]';
%control=[-0.1,1.7;-0.2,1.5;-0.1,-0.8;0.5,2.4]';
%t = linspace(0,1,21);       % 21 points per curve
%letter = [];                % initialize data to plot
%curves = length(nodes)-1;   % curves are between nodes
%for k=1:(length(nodes)-1)   % one curve for each interval
%  letter = [letter,Bezier(nodes(:,k:k+1),control(:,k:k+1),t)];
%end
%% plot interpolant, control points and nodes
%plot(letter(1,:),letter(2,:),control(1,:),...
%  control(2,:),'s',nodes(1,:),nodes(2,:),'o');
%\end{verbatim}
%````\\%\begin{figure}
%  \centering
%  \includegraphics[width=\textwidth]{letterexambezier}
%  \caption{B\'ezier cubic curve interpolation (see {doc}`demos/bezier`).}
%  \label{fig:exabezier}
%\end{figure}
%
%The four polynomials appearing in the definition {eq}`bezier` are
%called **Bernstein polynomials** and can be generalized to any
%degree. Furthermore, the Bernstein polynomials themselves are special
%cases of B-splines that have repeated knots (see
%Problem~\ref{pro:coincidentknots} on
%p.~\pageref{pro:coincidentknots}). In fact B-splines are usually
%preferred to B\'{e}zier curves in advanced implementations.
%
%## Problems
%\begin{exercises}
%\item Manipulate the example ``V&quot; to see how the curves change; provide two alternative
%styles of V's.
%by moving nodes and control points.  Can you improve the appearance of this
%letter?
%\item Create a ``Z&quot; in a similar style by modifying the example.
%\item Improve the example function to take graphical input for the nodes first
%and then the control points to generate the initial attempt to make a letter (say).
%\end{exercises}
\end{aligned}\end{align} \]</div>
</div></div></div></div>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tobin A. Driscoll and Richard J. Braun<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>