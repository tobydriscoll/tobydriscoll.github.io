

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Adaptive integration &#8212; Fundamentals of Numerical Computation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/proof.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .secondtoggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"float": ["\\mathbb{F}"], "real": ["\\mathbb{R}"], "complex": ["\\mathbb{C}"], "nat": ["\\mathbb{N}"], "integer": ["\\mathbb{Z}"], "rmn{([^}]*)}{([^}]*)}": ["\\mathbb{R}^{#1 \\times #2}", 2], "dd{([^}]*)}{([^}]*)}": ["\\frac{d #1}{d #2}", 2], "ddd{([^}]*)}{([^}]*)}": ["\\frac{d^2 #1}{d #2^2}", 2], "pp{([^}]*)}{([^}]*)}": ["\\frac{\\partial #1}{\\partial #2}", 2], "ppp{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2^2}", 2], "ppdd{([^}]*)}{([^}]*)}{([^}]*)}": ["\\frac{\\partial^2 #1}{\\partial #2 \\partial #3}", 3], "norm{([^}]*)}": ["\\| #1 \\|", 1], "twonorm{([^}]*)}": ["\\| #1 \\|_2", 1], "onenorm{([^}]*)}": ["\\| #1 \\|_1", 1], "infnorm{([^}]*)}": ["\\| #1 \\|_\\infty", 1], "anynorm{([^}]*)}{([^}]*)}": ["\\| #1 \\|_#2", 2], "innerprod{([^}]*)}{([^}]*)}": ["\\langle #1,#2 \\rangle", 2], "pr{([^}]*)}": ["^{(#1)}", 1], "kron{([^}]*)}{([^}]*)}": ["#1 \\otimes #2", 2], "eye{([^}]*)}": ["\\mathbf{e}_#1", 1], "meye": ["\\mathbf{I}"], "Qhat": ["\\hat{\\mathbf{Q}}"], "Rhat": ["\\hat{\\mathbf{R}}"], "bfalpha": ["\\mathbf{alpha}"], "bfdelta": ["\\mathbf{delta}"], "bfzero": ["\\boldsymbol{0}"], "macheps": ["\\epsilon_\\text{mach}"], "fl": ["\\operatorname{fl}"], "diag": ["\\operatorname{diag}"], "ign": ["\\operatorname{sign}"], "Re": ["\\operatorname{Re}"], "Im": ["\\operatorname{Im}"], "ee": ["\\times 10^"], "lnorm": ["\\|"], "rnorm": ["\\|"], "floor": ["\\lfloor#1\\rfloor", 1]}}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Initial-value problems for ODEs" href="../ivp/overview.html" />
    <link rel="prev" title="Numerical integration" href="integration.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Fundamentals of Numerical Computation</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="../frontmatter.html">Front matter</a>
  </li>
  <li class="">
    <a href="../intro/overview.html">Introduction</a>
  </li>
  <li class="">
    <a href="../linsys/overview.html">Square linear systems</a>
  </li>
  <li class="">
    <a href="../leastsq/overview.html">Overdetermined linear systems</a>
  </li>
  <li class="">
    <a href="../nonlineqn/overview.html">Roots of nonlinear equations</a>
  </li>
  <li class="active">
    <a href="overview.html">Piecewise interpolation</a>
  <ul class="nav sidenav_l2">
    <li class="">
      <a href="interpolation.html">The interpolation problem</a>
    </li>
    <li class="">
      <a href="pwlin.html">Piecewise linear interpolation</a>
    </li>
    <li class="">
      <a href="splines.html">Cubic splines</a>
    </li>
    <li class="">
      <a href="finitediffs.html">Finite differences</a>
    </li>
    <li class="">
      <a href="fd-converge.html">Convergence of finite differences</a>
    </li>
    <li class="">
      <a href="integration.html">Numerical integration</a>
    </li>
    <li class="active">
      <a href="">Adaptive integration</a>
    </li>
  </ul>
  </li>
  <li class="">
    <a href="../ivp/overview.html">Initial-value problems for ODEs</a>
  </li>
  <li class="">
    <a href="../appendix/linear-algebra.html">Review: Linear algebra</a>
  </li>
  <li class="">
    <a href="../appendix/demos.html">All demo notebooks</a>
  </li>
  <li class="">
    <a href="../genindex.html">Index</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="../_sources/localapprox/adaptive.md.txt"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.md</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Edit this page -->
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#error-estimation" class="nav-link">Error estimation</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#divide-and-conquer" class="nav-link">Divide and conquer</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#implementation" class="nav-link">Implementation</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#exercises" class="nav-link">Exercises</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="adaptive-integration">
<h1>Adaptive integration<a class="headerlink" href="#adaptive-integration" title="Permalink to this headline">¶</a></h1>
<p id="index-0">To this point, we have used only equally spaced nodes to compute integrals. Yet there are problems in which non-uniformly distributed nodes would clearly be more appropriate.</p>
<div class="proof proof-type-demo">

    <div class="proof-title">
        <span class="proof-type">Demo </span>
        
    </div><div class="proof-content">
<p><a class="reference internal" href="demos/adapt-motive.html"><span class="doc">An oscillatory integrand</span></a></p>
</div></div><p>We would like an algorithm that automatically detects and reacts to a situation like that in <a class="reference internal" href="demos/adapt-motive.html"><span class="doc">An oscillatory integrand</span></a>, a trait known as <strong>adaptivity</strong>.</p>
<div class="section" id="error-estimation">
<h2>Error estimation<a class="headerlink" href="#error-estimation" title="Permalink to this headline">¶</a></h2>
<p id="index-1">Ideally, we would like to make adaptation decisions based on the error of the integration. Knowing the error exactly would be equivalent to knowing the exact answer, but we can estimate it using the extrapolation technique of <a class="reference internal" href="integration.html"><span class="doc">Numerical integration</span></a>. Consider the Simpson formula <a class="reference internal" href="integration.html#equation-extraplevel1">(156)</a> resulting from one level of extrapolation from trapezoid estimates:</p>
<div class="math notranslate nohighlight" id="equation-extraplevel1repeat">
<span class="eqno">(161)<a class="headerlink" href="#equation-extraplevel1repeat" title="Permalink to this equation">¶</a></span>\[  S_f(2n) = \frac{1}{3} \Bigl[ 4 T_f(2n) - T_f(n) \Bigr].\]</div>
<p>We expect this method to be fourth-order accurate, i.e.,</p>
<div class="math notranslate nohighlight">
\[  \int_a^b f(x)\, dx = S_f(2n) + O(n^{-4}),\]</div>
<p>We can further extrapolate to sixth-order accuracy by <a class="reference internal" href="integration.html#equation-nc-sixth">(157)</a>,</p>
<div class="math notranslate nohighlight" id="equation-extraplevel2repeat">
<span class="eqno">(162)<a class="headerlink" href="#equation-extraplevel2repeat" title="Permalink to this equation">¶</a></span>\[  R_f(4n) = \frac{1}{15} \Bigl[ 16 S_f(4n) - S_f(2n) \Bigr].\]</div>
<p>By virtue of higher order of accuracy, <span class="math notranslate nohighlight">\(R_f(4n)\)</span> should be more accurate than <span class="math notranslate nohighlight">\(S_f(4n)\)</span>. Hence a decent estimate of the error in the better of the two Simpson values is</p>
<div class="math notranslate nohighlight" id="equation-adapterr">
<span class="eqno">(163)<a class="headerlink" href="#equation-adapterr" title="Permalink to this equation">¶</a></span>\[  E = R_f(4n) - S_f(4n) = \frac{S_f(4n) - S_f(2n)}{15}.\]</div>
</div>
<div class="section" id="divide-and-conquer">
<h2>Divide and conquer<a class="headerlink" href="#divide-and-conquer" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math notranslate nohighlight">\(|E|\)</span> is judged to be acceptably small, we are done. This judgment takes some care. For instance, suppose the exact integral is <span class="math notranslate nohighlight">\(10^{20}\)</span>.  Requiring <span class="math notranslate nohighlight">\(|E| &lt; \delta\ll 1\)</span> would be fruitless in double precision, since it would require more than 20 accurate digits. Hence checking the absolute size of the error alone is not appropriate. Conversely, consider the integral</p>
<div class="math notranslate nohighlight">
\[  \int_{10^{-6}}^{2\pi} 2 \sin x\, dx \approx -10^{-12}.\]</div>
<p>We are likely to sample values of the integrand that are larger than, say, <span class="math notranslate nohighlight">\(1/2\)</span> in absolute value, so obtaining this very small result has to rely on subtractive cancellation. We cannot hope for more than 4-5 accurate digits, so a strict test of the relative error is also not recommended.\footnote{In other words, we can have an error that is small relative to the data (the integrand), which is <span class="math notranslate nohighlight">\(O(1)\)</span>, but not relative to the answer itself.} Typically we use both relative and absolute error, stopping when either one is considered small enough. Algebraically, the test is</p>
<div class="math notranslate nohighlight" id="equation-absreltolerance">
<span class="eqno">(164)<a class="headerlink" href="#equation-absreltolerance" title="Permalink to this equation">¶</a></span>\[  |E| &lt; \delta_a + \delta_r |S_f(n)|,\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_a\)</span> and <span class="math notranslate nohighlight">\(\delta_r\)</span> are given absolute and relative error tolerances, respectively.</p>
<p>When <span class="math notranslate nohighlight">\(|E|\)</span> fails to meet <a class="reference internal" href="#equation-absreltolerance">(164)</a>, we bisect the interval <span class="math notranslate nohighlight">\([a,b]\)</span> to exploit the identity</p>
<div class="math notranslate nohighlight">
\[  \int_a^b f(x)\, dx = \int_a^{(a+b)/2} f(x)\, dx + \int_{(a+b)/2}^b f(x)\, dx,\]</div>
<p>and independently compute estimates to each of the half-length integrals. Each of these half-sized computations recursively applies Simpson’s formula and the error estimation criterion, making further bisections as necessary. Such an approach is called <strong>divide and conquer</strong> in computer science: recursively split the problem into easier pieces and glue the results together.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>It is typical to use just the minimal formula <span class="math notranslate nohighlight">\(S_f(4)\)</span> and its error estimate <span class="math notranslate nohighlight">\(E\)</span> to make decisions about adaptivity. A computation of <span class="math notranslate nohighlight">\(S_f(4)\)</span> requires three trapezoid estimates <span class="math notranslate nohighlight">\(T_f(1)\)</span>, <span class="math notranslate nohighlight">\(T_f(2)\)</span>, and <span class="math notranslate nohighlight">\(T_f(4)\)</span>. As observed in <a class="reference internal" href="integration.html#equation-nc-doubling">(158)</a> and <a class="reference internal" href="demos/int-extrap.html"><span class="doc">Extrapolation for numerical integration</span></a>, the five integrand evaluations in <span class="math notranslate nohighlight">\(T_f(4)\)</span> are sufficient to compute all of these values. There is one further exploitation of node locations to be found. For simplicity, assume <span class="math notranslate nohighlight">\([a,b]=[0,1]\)</span>. The five nodes used in <span class="math notranslate nohighlight">\(T_f(4)\)</span> are</p>
<div class="math notranslate nohighlight">
\[0, \quad \frac{1}{4}, \quad  \frac{1}{2}, \quad  \frac{3}{4}, \quad 1.\]</div>
<p>If we bisect the interval and compute <span class="math notranslate nohighlight">\(T_f(4)\)</span> on the subinterval <span class="math notranslate nohighlight">\([0,1/2]\)</span>, we use the nodes</p>
<div class="math notranslate nohighlight">
\[0, \quad \frac{1}{8}, \quad  \frac{1}{4}, \quad  \frac{3}{8}, \quad \frac{1}{2}.\]</div>
<p>Only the second and fourth nodes are new. The same is true on the subinterval <span class="math notranslate nohighlight">\([1/2,1]\)</span>, and for every recursive bisection.</p>
<p><a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> shows how to exploit this structure. The nested function <code class="docutils literal notranslate"><span class="pre">do_integral</span></code> does all of the work. It expects to receive the three nodes and integrand values that it shares with the level above. It adds the two new nodes and uses the set of all five to compute three trapezoid estimates with <span class="math notranslate nohighlight">\(n=1\)</span>, <span class="math notranslate nohighlight">\(n=2\)</span>, and <span class="math notranslate nohighlight">\(n=4\)</span>, using the updating formula <a class="reference internal" href="integration.html#equation-nc-doubling">(158)</a> twice. It goes on to find the two Simpson approximations and to estimate the error in the better one by <a class="reference internal" href="#equation-adapterr">(163)</a>.</p>
<p>If the error estimate passes the test <a class="reference internal" href="#equation-absreltolerance">(164)</a>, the better Simpson value is returned as the integral over the given interval. Otherwise, the interval is bisected, the two pieces computed using recursive calls, and those results are added to give the complete integral.</p>
<div class="proof proof-type-function" id="id1">
<span id="function-intadapt"></span>
    <div class="proof-title">
        <span class="proof-type">Function 56</span>
        
            <span class="proof-title-name">(intadapt)</span>
        
    </div><div class="proof-content">
<p><strong>Adaptive integration with error estimation.</strong></p>
<div class="highlight-julia notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="s">&quot;&quot;&quot;</span>
<span class="s">    intadapt(f,a,b,tol)</span>

<span class="s">Do adaptive integration to estimate the integral of `f` over [`a`,`b`] to desired</span>
<span class="s">error tolerance `tol`. Returns estimate and a vector of evaluation nodes used.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="k">function</span> <span class="n">intadapt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
    <span class="c"># Use error estimation and recursive bisection.</span>
    <span class="k">function</span> <span class="n">do_integral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">fa</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">fb</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">fm</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
        <span class="c"># These are the two new nodes and their f-values.</span>
        <span class="n">xl</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="n">fl</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xl</span><span class="p">);</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="n">fr</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xr</span><span class="p">);</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">xl</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">xr</span><span class="p">,</span><span class="n">b</span><span class="p">]</span>              <span class="c"># all 5 nodes at this level</span>

        <span class="c"># Compute the trapezoid values iteratively.</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span>
        <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="p">(</span><span class="n">fa</span><span class="o">+</span><span class="n">fb</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">fm</span>
        <span class="n">T</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fl</span><span class="o">+</span><span class="n">fr</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>      <span class="c"># Simpson values</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">15</span>           <span class="c"># error estimate</span>

        <span class="k">if</span> <span class="n">abs</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>  <span class="c"># acceptable error?</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>                   <span class="c"># yes--done</span>
        <span class="k">else</span>
            <span class="c"># Error is too large--bisect and recurse.</span>
            <span class="n">QL</span><span class="p">,</span><span class="n">tL</span> <span class="o">=</span> <span class="n">do_integral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">fa</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">fm</span><span class="p">,</span><span class="n">xl</span><span class="p">,</span><span class="n">fl</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">QR</span><span class="p">,</span><span class="n">tR</span> <span class="o">=</span> <span class="n">do_integral</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">fm</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">fb</span><span class="p">,</span><span class="n">xr</span><span class="p">,</span><span class="n">fr</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">QL</span> <span class="o">+</span> <span class="n">QR</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">tL</span><span class="p">;</span><span class="n">tR</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="k">end</span><span class="p">]]</span>         <span class="c"># merge the nodes w/o duplicate</span>
        <span class="k">end</span>
        <span class="k">return</span> <span class="n">Q</span><span class="p">,</span><span class="n">t</span>
    <span class="k">end</span>

    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">Q</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">do_integral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">b</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">m</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="n">tol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Q</span><span class="p">,</span><span class="n">t</span>
<span class="k">end</span>
</pre></div>
</td></tr></table></div>
</div></div><div class="proof proof-type-demo">

    <div class="proof-title">
        <span class="proof-type">Demo </span>
        
    </div><div class="proof-content">
<p><a class="reference internal" href="demos/adapt-usage.html"><span class="doc">Adaptive integration</span></a></p>
</div></div><p>Although adaptivity and the error estimation that goes with it can be very powerful, they come at some cost. The error estimation cannot be universally perfect, so sometimes the answer will not be as accurate as requested (underestimation) and sometimes the function will be evaluated more times than necessary (overestimation). Subtle problems may arise when the integral is a step within a larger computation (see <a class="reference internal" href="#problem-adapt-int-nonsmooth"><span class="std std-ref">this exercise below</span></a>).</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<span class="target" id="problem-adaptquadtests"></span><ol>
<li><p>⌨️ For each integral below, use <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> with error tolerance <span class="math notranslate nohighlight">\(10^{-2}\)</span>, <span class="math notranslate nohighlight">\(10^{-3}\)</span>, \ldots, <span class="math notranslate nohighlight">\(10^{-12}\)</span>. Make a table of errors and the number of integrand evaluation nodes used, and use a convergence plot as in <a class="reference internal" href="demos/adapt-usage.html"><span class="doc">Adaptive integration</span></a> to compare to fourth-order accuracy. (These integrals were taken from \cite{Bailey2005}.)</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(\displaystyle \int_0^1 x\log(1+x)\, dx = \frac{1}{4}\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(\displaystyle \int_0^1 x^2 \tan^{-1}x\, dx = \frac{\pi-2+2\log 2}{12}\)</span></p>
<p><strong>(c)</strong> <span class="math notranslate nohighlight">\(\displaystyle \int_0^{\pi/2}e^x \cos x\, dx = \frac{e^{\pi/2}-1}{2}\)</span></p>
<p><strong>(d)</strong> <span class="math notranslate nohighlight">\(\displaystyle \int_{0}^1 \sqrt{x} \log(x) \, dx = -\frac{4}{9}\)</span> (Note: Although the integrand has the limiting value zero as <span class="math notranslate nohighlight">\(x\to 0\)</span>, you have to implement the function carefully to return zero as the value of <span class="math notranslate nohighlight">\(f(0)\)</span>, or start the integral at <span class="math notranslate nohighlight">\(x=\macheps\)</span>.)</p>
<p><strong>(d)</strong> <span class="math notranslate nohighlight">\(\displaystyle \int_0^1 \sqrt{1-x^2}\, dx = \frac{\pi}{4}\)</span></p>
</li>
<li><p>⌨️ For each integral below: (i) use <code class="docutils literal notranslate"><span class="pre">quadgk</span></code> to find the value to at least 12 digits; (ii) use <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> to evaluate the integral to a tolerance of <span class="math notranslate nohighlight">\(10^{-8}\)</span>; (iii) compute the absolute error and the number of nodes used; (iv) use the <span class="math notranslate nohighlight">\(O(h^2)\)</span> term in the Euler–Maclaurin formula <a class="reference internal" href="integration.html#equation-eulermaclaurin">(151)</a> to estimate how many nodes are required by the fixed-stepsize trapezoidal formula to reach an absolute error of <span class="math notranslate nohighlight">\(10^{-8}\)</span>.</p>
<p><strong>(a)</strong> <span class="math notranslate nohighlight">\(\displaystyle \int_{0.1}^3 \operatorname{sech}(\sin(1/x))\d x\)</span></p>
<p><strong>(b)</strong> <span class="math notranslate nohighlight">\(\displaystyle\int_{-0.9}^9 \ln((x+1)^3))\d x\)</span></p>
<p><strong>(c)</strong> <span class="math notranslate nohighlight">\(\displaystyle\int_{-\pi}^\pi \cos(x^3)\d x\)</span></p>
</li>
<li><p>⌨️ An integral such as <span class="math notranslate nohighlight">\(\displaystyle \int_0^1 x^{-\gamma}\, dx\)</span> for <span class="math notranslate nohighlight">\(\gamma&gt;0\)</span>, in which the integrand blows up at one or both ends, is known as an <strong>improper</strong> integral. It has a finite value if <span class="math notranslate nohighlight">\(\gamma&lt;1\)</span>, despite the singularity. One way to deal with the problem of the infinite value for <span class="math notranslate nohighlight">\(f(t_0)\)</span> is to replace the lower limit with a small number <span class="math notranslate nohighlight">\(\epsilon\)</span>. Using <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> with a small tolerance, make a log–log plot of the error as a function of <span class="math notranslate nohighlight">\(\epsilon\)</span> for <span class="math notranslate nohighlight">\(\epsilon=10^{-15},10^{-16},\ldots,10^{-45}\)</span>. (A more robust way to handle improper integrals is discussed in a later chapter.)</p>
</li>
<li><p>⌨️ A curious consequence of our logic in <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> is that the algorithm uses what we believe to be a more accurate, sixth-order answer only for estimating error; the returned value is the supposedly less accurate <span class="math notranslate nohighlight">\(S_f(2n)\)</span>. The practice of returning the extrapolated <span class="math notranslate nohighlight">\(R_f(4n)\)</span> instead is called <span class="target" id="index-2"></span>local extrapolation <em>local extrapolation</em>. Modify <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> to use local extrapolation and repeat problem 1 above. Is the convergence more like 4th order or 6th order?</p>
</li>
<li><p>⌨️ The <strong>sine integral function</strong> is defined by</p>
<div class="math notranslate nohighlight">
\[\operatorname{Si}(x) = \int_0^x \frac{\sin z}{z}\, dz.\]</div>
<p>Use <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> to plot Si over the interval <span class="math notranslate nohighlight">\([1,10]\)</span>. Note: You will need to replace the lower bound of integration by <span class="math notranslate nohighlight">\(\macheps\)</span>.</p>
</li>
<li id="problem-adapt-int-nonsmooth"><p>⌨️  Adaptive integration can have subtle drawbacks. This exercise is based on the <strong>error function</strong>, a smooth function defined as</p>
<div class="math notranslate nohighlight">
\[\operatorname{erf}(x) = \frac{2}{\pi}\int_0^x e^{-s^2}\,ds.\]</div>
<p><strong>(a)</strong> Define a function <span class="math notranslate nohighlight">\(g\)</span> that approximates erf by applying <a class="reference internal" href="integration.html#function-trapezoid"><span class="std std-ref">trapezoid</span></a> with <span class="math notranslate nohighlight">\(n=100\)</span>. Make a plot of the error <span class="math notranslate nohighlight">\(g(x)-\operatorname{erf}(x)\)</span> at 300 points in the interval <span class="math notranslate nohighlight">\([0,3]\)</span>.</p>
<p><strong>(b)</strong> Define another approximation <span class="math notranslate nohighlight">\(h\)</span> that applies <a class="reference internal" href="#function-intadapt"><span class="std std-ref">intadapt</span></a> with error tolerance <span class="math notranslate nohighlight">\(10^{-7}\)</span>. Plot the error in <span class="math notranslate nohighlight">\(h\)</span> as in part~(a). Why does it look so different from the previous case?</p>
<p><strong>(c)</strong> Suppose you wished to find <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(\operatorname{erf}(x) = .95\)</span> by using rootfinding on one of your two approximations. Which would be preferable?</p>
</li>
</ol>
</div>
</div>


              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="integration.html" title="previous page">Numerical integration</a>
    <a class='right-next' id="next-link" href="../ivp/overview.html" title="next page">Initial-value problems for ODEs</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tobin A. Driscoll and Richard J. Braun<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>