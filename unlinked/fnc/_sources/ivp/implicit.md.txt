# Implementation of multistep methods

We now consider some of the practical issues that arise when multistep formulas are used to solve IVPs. Implementation of the explicit case is relatively straightforward. In what follows we use boldface for the vector form of the problem, $\mathbf{u}'=\mathbf{f}(t,\mathbf{u})$. For instance, the explicit AB4 method is defined by the formula

```{math}
:label: ab4
\mathbf{u}_{i+1} = \mathbf{u}_i + \frac{h}{24} ( 55\mathbf{f}_i - 59 \mathbf{f}_{i-1} +37\mathbf{f}_{i-2} -9\mathbf{f}_{i-3}), \quad i=3,\ldots,n-1.
```

{ref}`function-ab4` shows a basic implementation of this formula. Observe that {ref}`function-rk4` is used to find the starting values $\mathbf{u}_1,\mathbf{u}_2,\mathbf{u}_3$ that are needed before the iteration formula takes over. As far as RK4 is concerned, it needs to solve the IVP over the time interval $a \le t \le a+3h$, using a step size $h$ (the same step size as in the AB4 iteration). These values are then used by {ref}`function-ab4` to find
$\mathbf{f}_0,\ldots,\mathbf{f}_3$ and get the main iteration started.

For each value of $i$ the formula uses the four most recently known values of the solution's derivative in order to advance by one step. In {ref}`function-ab4` only these values of $\mathbf{f}$ are stored, and a matrix-vector product is used for the linear combination implied in {eq}`ab4`:

```{math}
  :label: ab4mv
  \mathbf{u}_{i+1} = \mathbf{u}_i + h
  \begin{bmatrix}
    \mathbf{f}_i & \mathbf{f}_{i-1} & \mathbf{f}_{i-2} & \mathbf{f}_{i-3}
  \end{bmatrix}
  \begin{bmatrix}
    55/24 \\[1mm] -59/24 \\[1mm] 37/24 \\[1mm]-9/24
  \end{bmatrix}.
```

We have distributed the factor of $1/24$ in order to point out that the $4\times 1$ constant vector is just the vector of coefficients of the generating polynomial $\sigma(z)$ from {eq}`sigma`. At the start of an iteration, the value of $\mathbf{f}$ at the most recent solution step is unknown, so a call is made to evaluate it, and the other columns are shifted to the right (i.e., into the past).

(function-ab4)=

````{proof:function} ab4
**4th-order Adams--Bashforth formula for an IVP.**

```{code-block} julia
:lineno-start: 1
```
````

```{proof:demo}
{doc}`demos/implicit-ab4`
```

## Implicit methods

(function-am2)=

````{proof:function} am2
**2nd-order Adams--Moulton (trapezoid) formula for an IVP.**

```{code-block} julia
:lineno-start: 1
```
````

The implementation of an implicit multistep method is a bit more involved. Consider the second-order implicit formula AM2, also known as the trapezoid method. To advance from step $i$ to $i+1$, we need to solve

```{math}
  :label: AM2solve
  \mathbf{z} - \mathbf{u}_i - \tfrac{1}{2} h \bigl[ \mathbf{f}(t_i,\mathbf{u}_i) + f(t_{i+1},\mathbf{z}) \bigr] = 0
```

for $\mathbf{z}$, and then set $\mathbf{u}_{i+1}=\mathbf{z}$. This equation takes the form $\mathbf{g}(\mathbf{z})=\boldsymbol{0}$, so we have a rootfinding problem as in {doc}`../nonlineqn/overview`. An implementation of AM2 using {ref}`function-levenberg` from {doc}`../nonlineqn/quasinewton` is shown in {ref}`function-am2`. It defines a nested function called "trapzero" that evaluates the left-hand side of {eq}`AM2solve`, given any value of $\mathbf{z}$. The time stepping iteration calls "levenberg" at each step, starting from the value $\mathbf{u}_i+\tfrac{1}{2}h\mathbf{f}_i$ that is halfway between $\mathbf{u}_i$ and the Euler step $\mathbf{u}_i+h\mathbf{f}_i$. A robust code would have to intercept the case where {ref}`function-levenberg` fails to converge, but we have ignored this issue for the sake of simplicity.

## Stiff problems

At each time step in {ref}`function-am2` (or any implicit IVP solver), a rootfinding iteration of unknown length is needed. This fact makes the cost of an implicit method much greater on a per-step basis than for an explicit one. Given this drawback, you are justified to wonder whether implicit methods are ever competitive! The answer is emphatically yes, as the following simple example shows.

```{proof:demo}
{doc}`demos/implicit-stiff`
```

Although the result of {doc}`demos/implicit-stiff` may seem strange, there is no contradiction: a fourth-order explicit formula is indeed more accurate than a second-order implicit one, in the limit $h\to 0$. But there is another limit to consider, $t\to \infty$ with $h$ fixed, and in this one the implicit method wins. Such problems are called \index{stiff problem} {term}`stiff`. A complete mathematical description lies in \secref{stiffness}, but a sure sign of stiffness is the presence of phenomena on widely different time scales. In the example, there is "slow time," where the solution changes very little, and "fast time," when it suddenly jumps from zero to one. For stiff problems, implicit methods are usually preferred, because they can take far fewer steps than an explicit method, more than offsetting the extra work required per step.

## Adaptivity

As with RK methods, we can run two time stepping methods simultaneously in order to estimate the error and adjust the step size accordingly. For example, we could pair AB3 with AB4 as practically no cost, because the methods differ only in how they include known information from the recent past. The more accurate AB4 value should allow an accurate estimate of the local error in the AB3 value, and so on.

Because multistep methods rely on the solution history, though, changing the step size is more complicated than for RK methods. If $h$ is changed, then the historical values $\mathbf{u}_{i-1},\mathbf{u}_{i-2}\ldots$ and $\mathbf{f}_{i-1},\mathbf{f}_{i-2}\ldots$ are no longer given at the right moments in time to apply the iteration formula. A typical remedy is to use interpolation to re-evaluate the historical values at the appropriate times. The details are important but not especially illuminating, and we do not give them here.
<!-- 

\begin{exercises}
  \input{ivpns/exercises/MultistepImplement}
\end{exercises} -->
