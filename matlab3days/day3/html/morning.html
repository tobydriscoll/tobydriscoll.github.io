
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>morning</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-08-01"><meta name="DC.source" content="morning.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
      MathJax.Hub.Config({
        jax: ["input/TeX","output/HTML-CSS"],
      });
    </script></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Scripts and functions</a></li><li><a href="#3">Scripts</a></li><li><a href="#6">Functions</a></li><li><a href="#12">Lambda functions (anonymous functions)</a></li><li><a href="#21">Subfunctions and nested functions.</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> morning
</pre><h2>Scripts and functions<a name="2"></a></h2><p>Toby Driscoll, July 2014</p><pre class="codeinput">clear, close <span class="string">all</span>
</pre><h2>Scripts<a name="3"></a></h2><p>A script is simply a list of MATLAB commands that go in a text file. When it is run, the effect is exactly the same as if those commands had been typed in.</p><p>In order to be run, the script is saved as an "M-file", as in "myscript.m". The folder/directory where the file is saved must be on MATLAB's path. Then the name of the file is typed in at the command line, e.g., "myscript", to run the script.</p><p>Scripts are a good way to gather a medium set of commands that you need to try again and again to experiment or debug. They are also useful to create documents like this one, using the <tt>publish</tt> facility.</p><h2>Functions<a name="6"></a></h2><p>Like scripts, functions are collections of MATLAB commands, saved as a text file with the extension "*.m". However, they behave quite differently.</p><p>Each function gets its own variable workspace. The function knows nothing of variables that were defined outside of it, and its variables cannot be seen from the command line (the "base" workspace) or from other functions. This setup means that you can use common variable names, like <tt>x</tt>, knowing that you won't come into conflict with the same variable names elsewhere.</p><p>In order to communicate with other variable workspaces, functions have input and output arguments. These are declared in the first line of the function. For example,</p><pre class="codeinput"><span class="keyword">function</span> [r1,r2] = quadform(a,b,c)
  D = sqrt(b^2-4*a*c);
  r1 = (-b+D)/(2*a);
  r2 = (-b-D)/(2*a);
<span class="keyword">end</span>
</pre><p>The first line says that whatever invokes the function is supposed to provide three values, which the function defines by the names <tt>a</tt>, <tt>b</tt>, and <tt>c</tt>. At the end of the function, two values will be returned to the caller: the values held by <tt>r1</tt> and <tt>r2</tt> when the function ends.</p><p>The function and the caller do not have to use the same names for the arguments. In fact, they may not have names at all in the caller:</p><pre class="codeinput">[x1,x2] = quadform(1,-2,3)
</pre><pre class="codeoutput">
x1 =

   1.0000 + 1.4142i


x2 =

   1.0000 - 1.4142i

</pre><p>Note that executing the function created no variables that we have access to.</p><pre class="codeinput">b_exists = exist(<span class="string">'b'</span>)
</pre><pre class="codeoutput">
b_exists =

     0

</pre><h2>Lambda functions (anonymous functions)<a name="12"></a></h2><p>Sometimes you want to create a short function without writing a file for it. There is a mechanism that MATLAB calls anonymous functions (and the rest of the world's languages call lambda functions) for this. For example:</p><pre class="codeinput">sincos = @(x) sin(x).*cos(x)
</pre><pre class="codeoutput">
sincos = 

    @(x)sin(x).*cos(x)

</pre><pre class="codeinput">sincos(pi/4)
</pre><pre class="codeoutput">
ans =

    0.5000

</pre><p>These functions can take more than one input argument, but cannot return more than one output, and they must consist of a single expression (not multiple lines).</p><p>One common way to use these functions is to create a "wrapper". For example, suppose we want to use <tt>interp1</tt> to create a function from data that can be called multiple times. We can use the full syntax of <tt>interp1</tt> each time, of course.</p><pre class="codeinput">cdate = []; pop = [];
load <span class="string">census</span>
interp1(cdate,pop,1995,<span class="string">'pchip'</span>)
interp1(cdate,pop,1996,<span class="string">'pchip'</span>)
</pre><pre class="codeoutput">
ans =

  260.0604


ans =

  262.3528

</pre><p>But this requires computation of the interpolant's parameters every time. There is an alternate output type to help avoid this problem.</p><pre class="codeinput">pp = interp1(cdate,pop,<span class="string">'pchip'</span>,<span class="string">'pp'</span>);
</pre><p>Now we can use <tt>ppval</tt> to evaluate much faster.</p><pre class="codeinput">ppval(pp,1995)
ppval(pp,1996)
</pre><pre class="codeoutput">
ans =

  260.0604


ans =

  262.3528

</pre><p>However, this lacks elegance and requires you to pass around the <tt>pp</tt> variable and remember what it's for. Instead, we can create a proper, callable function.</p><pre class="codeinput">f = @(x) ppval(pp,x)
f(1995)
f(1996)
</pre><pre class="codeoutput">
f = 

    @(x)ppval(pp,x)


ans =

  260.0604


ans =

  262.3528

</pre><p>If you pass <tt>f</tt> into another function, it will remain callable, even if you don't pass in the <tt>pp</tt> data. In other words, the definition of <tt>f</tt> is "closed" or self-contained.</p><pre class="codeinput"><span class="keyword">function</span> y = greatyear(f)
    y = f(1987);
<span class="keyword">end</span>
</pre><pre class="codeinput">greatyear(f)
</pre><pre class="codeoutput">
ans =

  241.9661

</pre><h2>Subfunctions and nested functions.<a name="21"></a></h2><p>If you have one function that relies on other helper functions to do its job, you can put them all in one file. The file name should match that of the first function. That function is the only one that will be visible and callable from outside the function, but the main function and subfunctions can all see each other.</p><p>function mainfunc(x,y)</p><pre class="codeinput"><span class="keyword">...</span>
</pre><p>end</p><p>function w = helperfunc(z)</p><pre class="codeinput"><span class="keyword">...</span>
</pre><p>end</p><p>Nested functions are trickier. They are defined in a nested fashion.</p><p>function mainfunc(x,y)</p><pre class="codeinput"><span class="keyword">...</span>
</pre><pre>   function w = helperfunc(z)</pre><pre>     ...</pre><pre>   end</pre><p>end</p><p>Now helperfunc is still callable from within mainfunc, and not from outide the file. But there is a big difference. Any variable name that is used inside both the child function and its parent are the same variable. This aspect of nested functions violates the private workspace principle and should be used cautiously, but sometimes it is much more convenient than any alternative.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 8.1<br></p></div><!--
##### SOURCE BEGIN #####
function morning

%% Scripts and functions
% Toby Driscoll, July 2014
clear, close all

%% Scripts
% A script is simply a list of MATLAB commands that go in a text file. When
% it is run, the effect is exactly the same as if those commands had been
% typed in.

%%
% In order to be run, the script is saved as an "M-file", as in
% "myscript.m". The folder/directory where the file is saved must be on
% MATLAB's path. Then the name of the file is typed in at the command line,
% e.g., "myscript", to run the script.

%%
% Scripts are a good way to gather a medium set of commands that you need
% to try again and again to experiment or debug. They are also useful to
% create documents like this one, using the |publish| facility.

%% Functions
% Like scripts, functions are collections of MATLAB commands, saved as a
% text file with the extension "*.m". However, they behave quite
% differently. 

%%
% Each function gets its own variable workspace. The function knows nothing
% of variables that were defined outside of it, and its variables cannot be
% seen from the command line (the "base" workspace) or from other
% functions. This setup means that you can use common variable names, like
% |x|, knowing that you won't come into conflict with the same variable
% names elsewhere.

%%
% In order to communicate with other variable workspaces, functions have
% input and output arguments. These are declared in the first line of the
% function. For example,

function [r1,r2] = quadform(a,b,c)
  D = sqrt(b^2-4*a*c);
  r1 = (-b+D)/(2*a);
  r2 = (-b-D)/(2*a);
end

%%
% The first line says that whatever invokes the function is supposed to
% provide three values, which the function defines by the names |a|, |b|,
% and |c|. At the end of the function, two values will be returned to the
% caller: the values held by |r1| and |r2| when the function ends. 

%%
% The function and the caller do not have to use the same names for the
% arguments. In fact, they may not have names at all in the caller:
[x1,x2] = quadform(1,-2,3)

%%
% Note that executing the function created no variables that we have access
% to.
b_exists = exist('b')

%% Lambda functions (anonymous functions)
% Sometimes you want to create a short function without writing a file for
% it. There is a mechanism that MATLAB calls anonymous functions (and the
% rest of the world's languages call lambda functions) for this. For
% example:

sincos = @(x) sin(x).*cos(x)

%%
sincos(pi/4)

%%
% These functions can take more than one input argument, but cannot return
% more than one output, and they must consist of a single expression (not
% multiple lines).

%%
% One common way to use these functions is to create a "wrapper". For
% example, suppose we want to use |interp1| to create a function from data 
% that can be called multiple times. We can use the full syntax of |interp1|
% each time, of course.
cdate = []; pop = [];
load census
interp1(cdate,pop,1995,'pchip')
interp1(cdate,pop,1996,'pchip')

%%
% But this requires computation of the interpolant's parameters every time.
% There is an alternate output type to help avoid this problem. 
pp = interp1(cdate,pop,'pchip','pp');

%%
% Now we can use |ppval| to evaluate much faster.
ppval(pp,1995)
ppval(pp,1996)

%%
% However, this lacks elegance and requires you to pass around the |pp|
% variable and remember what it's for. Instead, we can create a proper,
% callable function.
f = @(x) ppval(pp,x)
f(1995)
f(1996)

%%
% If you pass |f| into another function, it will remain callable, even if
% you don't pass in the |pp| data. In other words, the definition of |f| is
% "closed" or self-contained. 

function y = greatyear(f)
    y = f(1987);
end

%%
greatyear(f)

%% Subfunctions and nested functions.
% If you have one function that relies on other helper functions to do its
% job, you can put them all in one file. The file name should match that of
% the first function. That function is the only one that will be visible
% and callable from outside the function, but the main function and
% subfunctions can all see each other. 

%%
% function mainfunc(x,y)
%
%   ... 
%
% end
%
% function w = helperfunc(z)
%
%   ... 
%
% end

%%
% Nested functions are trickier. They are defined in a nested fashion.

%%
% function mainfunc(x,y)
%
%   ...
%
%     function w = helperfunc(z)
%
%       ...
%
%     end
%
% end

%%
% Now helperfunc is still callable from within mainfunc, and not from
% outide the file. But there is a big difference. Any variable name that is
% used inside both the child function and its parent are the same variable.
% This aspect of nested functions violates the private workspace principle
% and should be used cautiously, but sometimes it is much more convenient
% than any alternative.

end



##### SOURCE END #####
--></body></html>