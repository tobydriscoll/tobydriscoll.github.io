
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>afternoon</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-08-06"><meta name="DC.source" content="afternoon.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
      MathJax.Hub.Config({
        jax: ["input/TeX","output/HTML-CSS"],
      });
    </script></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Functions of functions</a></li><li><a href="#3">Quadrature</a></li><li><a href="#7">Rootfinding</a></li><li><a href="#13">ODEs</a></li><li><a href="#20">Parameters</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> afternoon
</pre><h2>Functions of functions<a name="2"></a></h2><p>Toby Driscoll, July 2014</p><pre class="codeinput">close <span class="string">all</span>, clear
</pre><h2>Quadrature<a name="3"></a></h2><p>There are many problems that have a function as data. For example, take the problem of transforming a function into its definite integral. Approximating this transformation numerically is called quadrature.</p><p>In order to use a function as data, we need to create it anonymously, or refer to it with an @ sign in front (handle).</p><pre class="codeinput">integral( @sin,0,pi )
</pre><pre class="codeoutput">
ans =

   2.000000000000000

</pre><pre class="codeinput">f = @(x) sin(x).*cos(x);
integral(f,-pi,pi)
</pre><pre class="codeoutput">
ans =

     6.938893903907228e-17

</pre><pre class="codeinput">erf1 = 2/sqrt(pi)*integral(@(t) exp(-t.^2),0,1)
error = erf(1) - erf1
</pre><pre class="codeoutput">
erf1 =

   0.842700792949715


error =

     0

</pre><h2>Rootfinding<a name="7"></a></h2><p>Another prototypical problem is to find a root of a function. The built-in <tt>fzero</tt> is excellent for this.</p><pre class="codeinput">fzero(@sin,[1 4])
</pre><pre class="codeoutput">
ans =

   3.141592653589793

</pre><p>You can give either a starting point or a starting interval.</p><pre class="codeinput">fzero(@sin,2.5)
</pre><pre class="codeoutput">
ans =

   3.141592653589794

</pre><p>Giving the starting interval is preferred. It often takes fewer iterations, because the first step is to find an interval anyway.</p><pre class="codeinput">fzero(@sin,[1 4],optimset(<span class="string">'display'</span>,<span class="string">'iter'</span>))
</pre><pre class="codeoutput"> 
 Func-count    x          f(x)             Procedure
    2               4     -0.756802        initial
    3         2.57946       0.53299        interpolation
    4         3.16648    -0.0248858        interpolation
    5          3.1403    0.00129744        interpolation
    6         3.14159  -1.26972e-07        interpolation
    7         3.14159   3.56496e-14        interpolation
    8         3.14159   1.22465e-16        interpolation
    9         3.14159   1.22465e-16        interpolation
 
Zero found in the interval [1, 4]

ans =

   3.141592653589793

</pre><pre class="codeinput">fzero(@sin,2.5,optimset(<span class="string">'display'</span>,<span class="string">'iter'</span>))
</pre><pre class="codeoutput"> 
Search for an interval around 2.5 containing a sign change:
 Func-count    a          f(a)             b          f(b)        Procedure
    1             2.5      0.598472           2.5      0.598472   initial interval
    3         2.42929      0.653579       2.57071      0.540374   search
    5             2.4      0.675463           2.6      0.515501   search
    7         2.35858      0.705419       2.64142      0.479576   search
    9             2.3      0.745705           2.7       0.42738   search
   11         2.21716      0.798281       2.78284      0.351104   search
   13             2.1      0.863209           2.9      0.239249   search
   15         1.93431      0.934652       3.06569     0.0758344   search
   17             1.7      0.991665           3.3     -0.157746   search
 
Search for a zero in the interval [1.7, 3.3]:
 Func-count    x          f(x)             Procedure
   17             3.3     -0.157746        initial
   18         3.08042     0.0611393        interpolation
   19         3.14175  -0.000157317        interpolation
   20         3.14159   9.79215e-08        interpolation
   21         3.14159  -3.21625e-16        interpolation
   22         3.14159  -3.21625e-16        interpolation
 
Zero found in the interval [1.7, 3.3]

ans =

   3.141592653589794

</pre><p>Here's a more substantial example. The Lambert W function is defined as the inverse of the function <span class="MathJax_Preview"><img src="afternoon_eq26398.png" alt="$xe^x$"></span><script type="math/tex">xe^x</script>. In other words, <span class="MathJax_Preview"><img src="afternoon_eq55822.png" alt="$W(x)e^{W(x)}=x$"></span><script type="math/tex">W(x)e^{W(x)}=x</script>. For any given value of <span class="MathJax_Preview"><img src="afternoon_eq43551.png" alt="$x$"></span><script type="math/tex">x</script>, we can solve <span class="MathJax_Preview"><img src="afternoon_eq56460.png" alt="$we^w-x=0$"></span><script type="math/tex">we^w-x=0</script> for <span class="MathJax_Preview"><img src="afternoon_eq64535.png" alt="$w$"></span><script type="math/tex">w</script> to get <span class="MathJax_Preview"><img src="afternoon_eq19423.png" alt="$W(x)=w$"></span><script type="math/tex">W(x)=w</script>.</p><pre class="codeinput">    <span class="keyword">function</span> w = lambertW(x)
        f = @(w) w*exp(w) - x;
        guess = log(x);
        w = fzero(f,guess);
    <span class="keyword">end</span>
</pre><pre class="codeinput">format <span class="string">long</span>
point05 = lambertW( 0.05*exp(0.05) )
four = lambertW( 4*exp(4) )
</pre><pre class="codeoutput">
point05 =

   0.050000000000000


four =

     4

</pre><h2>ODEs<a name="13"></a></h2><p>The third classic problem with a function as data is an ordinary differential equation, <span class="MathJax_Preview"><img src="afternoon_eq67122.png" alt="$dy/dt = f(t,y)$"></span><script type="math/tex">dy/dt = f(t,y)</script>. In this case the function data is <span class="MathJax_Preview"><img src="afternoon_eq07790.png" alt="$f(t,y)$"></span><script type="math/tex">f(t,y)</script>. Here is the logistic equation:</p><pre class="codeinput">f = @(t,y) y.*(1-y);
</pre><p>And here is its solution for <span class="MathJax_Preview"><img src="afternoon_eq16293.png" alt="$t\in[0,10]$"></span><script type="math/tex">t\in[0,10]</script>, <span class="MathJax_Preview"><img src="afternoon_eq42775.png" alt="$y(0)=0.05$"></span><script type="math/tex">y(0)=0.05</script>.</p><pre class="codeinput">[t,y] = ode45( f, [0 10], 0.05 );
plot(t,y,<span class="string">'o-'</span>)
</pre><img vspace="5" hspace="5" src="afternoon_01.png" alt=""> <p>Certain problems are called "stiff" and make alternatives to <tt>ode45</tt> desirable. For example,</p><pre class="codeinput">f = @(t,r) r.^2-r.^3;
[t,y] = ode45(f,[0 160],0.01);
plot(t,y,<span class="string">'.-'</span>)
</pre><img vspace="5" hspace="5" src="afternoon_02.png" alt=""> <p>Using the "stiff solver" <tt>ode15s</tt> requires many fewer time points (though each is more expensive to compute!).</p><pre class="codeinput">[t,y] = ode15s(f,[0 160],0.01);
hold <span class="string">on</span>
plot(t,y+0.5,<span class="string">'.-r'</span>)
</pre><img vspace="5" hspace="5" src="afternoon_03.png" alt=""> <pre class="codeinput">clf
</pre><img vspace="5" hspace="5" src="afternoon_04.png" alt=""> <p>Second order problems have to be rewritten in first order form. For example, consider <span class="MathJax_Preview"><img src="afternoon_eq72955.png" alt="$u'' - u(1-u^2)u' + u = 0$"></span><script type="math/tex">u'' - u(1-u^2)u' + u = 0</script>. Introducing <span class="MathJax_Preview"><img src="afternoon_eq44762.png" alt="$y_1=u$"></span><script type="math/tex">y_1=u</script> and <span class="MathJax_Preview"><img src="afternoon_eq65980.png" alt="$y_2=u'$"></span><script type="math/tex">y_2=u'</script> leads to</p><pre class="codeinput">f = @(t,y) [ y(2); (1-y(1)^2)*y(2) - y(1) ];
[t,y] = ode45( f, [0 20], [1;0] );
plot(t,y,<span class="string">'o-'</span>)
</pre><img vspace="5" hspace="5" src="afternoon_05.png" alt=""> <p>Here it is in the phase plane.</p><pre class="codeinput">plot(y(:,1),y(:,2))
</pre><img vspace="5" hspace="5" src="afternoon_06.png" alt=""> <h2>Parameters<a name="20"></a></h2><p>These kinds of problems are where nested and anonymous functions can be handy. Let's consider the ODE above with a parameter <span class="MathJax_Preview"><img src="afternoon_eq68803.png" alt="$\mu$"></span><script type="math/tex">\mu</script>: <span class="MathJax_Preview"><img src="afternoon_eq02994.png" alt="$u'' - \mu u(1-u^2)u' + u = 0$"></span><script type="math/tex">u'' - \mu u(1-u^2)u' + u = 0</script>. We want to write a function for it that includes the parameter.</p><pre class="codeinput"><span class="keyword">function</span> dydt = myode(t,y,mu)

dydt = zeros(size(y));
dydt(1) = y(2);
dydt(2) = mu*(1-y(1)^2)*y(2) - y(1);

<span class="keyword">end</span>
</pre><p>(This function is actually nested inside the one for this file.) However, the ODE solver functions will accept functions of t and y only. We can bridge the gap using a "wrapper" anonymous function.</p><pre class="codeinput">mu = 10;
f = @(t,y) myode(t,y,mu)
</pre><pre class="codeoutput">
f = 

    @(t,y)myode(t,y,mu)

</pre><p>Now <tt>f</tt> is usable by <tt>ode45</tt> but also includes the assigned value of <tt>mu</tt>.</p><pre class="codeinput">[t,y] = ode45( f, [0 60], [1;0] );
plot(t,y,<span class="string">'o-'</span>)
</pre><img vspace="5" hspace="5" src="afternoon_07.png" alt=""> <p>Because <tt>myode</tt> is nested, it would have access to <tt>mu</tt> in the parent function if we left it out of the argument list.</p><pre class="codeinput"><span class="keyword">function</span> dydt = myode2(t,y)

dydt = zeros(size(y));
dydt(1) = y(2);
dydt(2) = mu*(1-y(1)^2)*y(2) - y(1);

<span class="keyword">end</span>
</pre><pre class="codeinput">[t,y] = ode45( @myode2, [0 60], [1;0] );
plot(y(:,1),y(:,2))
</pre><img vspace="5" hspace="5" src="afternoon_08.png" alt=""> <p>The wrapper style is usually preferable, but there are some circumstances where the shared workspace of a nested function is useful.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 8.3<br></p></div><!--
##### SOURCE BEGIN #####
function afternoon

%% Functions of functions
% Toby Driscoll, July 2014
close all, clear

%% Quadrature
% There are many problems that have a function as data. For example, take
% the problem of transforming a function into its definite integral.
% Approximating this transformation numerically is called quadrature.

%%
% In order to use a function as data, we need to create it anonymously, or
% refer to it with an @ sign in front (handle).
integral( @sin,0,pi )

%%
f = @(x) sin(x).*cos(x);
integral(f,-pi,pi)

%%
erf1 = 2/sqrt(pi)*integral(@(t) exp(-t.^2),0,1)
error = erf(1) - erf1

%% Rootfinding
% Another prototypical problem is to find a root of a function. The
% built-in |fzero| is excellent for this. 
fzero(@sin,[1 4])

%%
% You can give either a starting point or a starting interval.
fzero(@sin,2.5)

%%
% Giving the starting interval is preferred. It often takes fewer
% iterations, because the first step is to find an interval anyway.
fzero(@sin,[1 4],optimset('display','iter'))

%%
fzero(@sin,2.5,optimset('display','iter'))

%%
% Here's a more substantial example. The Lambert W function is defined as
% the inverse of the function $xe^x$. In other words, $W(x)e^{W(x)}=x$. For
% any given value of $x$, we can solve $we^w-x=0$ for $w$ to get $W(x)=w$. 
    function w = lambertW(x)
        f = @(w) w*exp(w) - x;
        guess = log(x);
        w = fzero(f,guess);
    end

%%
format long
point05 = lambertW( 0.05*exp(0.05) )
four = lambertW( 4*exp(4) )



%% ODEs
% The third classic problem with a function as data is an ordinary
% differential equation, $dy/dt = f(t,y)$. In this case the function data
% is $f(t,y)$. Here is the logistic equation:
f = @(t,y) y.*(1-y);

%%
% And here is its solution for $t\in[0,10]$, $y(0)=0.05$.
[t,y] = ode45( f, [0 10], 0.05 );
plot(t,y,'o-')

%%
% Certain problems are called "stiff" and make alternatives to
% |ode45| desirable. For example,
f = @(t,r) r.^2-r.^3;
[t,y] = ode45(f,[0 160],0.01);
plot(t,y,'.-')

%%
% Using the "stiff solver" |ode15s| requires many fewer time points (though
% each is more expensive to compute!).
[t,y] = ode15s(f,[0 160],0.01);
hold on
plot(t,y+0.5,'.-r')

%%
clf

%%
% Second order problems have to be rewritten in first order form. For
% example, consider $u'' - u(1-u^2)u' + u = 0$. Introducing $y_1=u$ and
% $y_2=u'$ leads to
f = @(t,y) [ y(2); (1-y(1)^2)*y(2) - y(1) ];
[t,y] = ode45( f, [0 20], [1;0] );
plot(t,y,'o-')

%%
% Here it is in the phase plane.
plot(y(:,1),y(:,2))

%% Parameters
% These kinds of problems are where nested and anonymous functions can be
% handy. Let's consider the ODE above with a parameter $\mu$: $u'' - \mu
% u(1-u^2)u' + u = 0$. We want to write a function for it that includes the
% parameter.

function dydt = myode(t,y,mu)

dydt = zeros(size(y));
dydt(1) = y(2); 
dydt(2) = mu*(1-y(1)^2)*y(2) - y(1);

end

%%
% (This function is actually nested inside the one for this file.) However,
% the ODE solver functions will accept functions of t and y only. We can
% bridge the gap using a "wrapper" anonymous function.
mu = 10;
f = @(t,y) myode(t,y,mu)

%%
% Now |f| is usable by |ode45| but also includes the assigned value of
% |mu|.
[t,y] = ode45( f, [0 60], [1;0] );
plot(t,y,'o-')

%%
% Because |myode| is nested, it would have access to |mu| in the parent
% function if we left it out of the argument list.
function dydt = myode2(t,y)

dydt = zeros(size(y));
dydt(1) = y(2); 
dydt(2) = mu*(1-y(1)^2)*y(2) - y(1);

end

%%
[t,y] = ode45( @myode2, [0 60], [1;0] );
plot(y(:,1),y(:,2))

%%
% The wrapper style is usually preferable, but there are some circumstances
% where the shared workspace of a nested function is useful. 

end


##### SOURCE END #####
--></body></html>