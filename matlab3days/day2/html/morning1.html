
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>morning1</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-08-05"><meta name="DC.source" content="morning1.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
      MathJax.Hub.Config({
        jax: ["input/TeX","output/HTML-CSS"],
      });
    </script></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Making matrices</a></li><li><a href="#5">Loops</a></li><li><a href="#8">No loops</a></li><li><a href="#10">Other 'atomic' operations</a></li><li><a href="#16">Indexing</a></li></ul></div><h2>Making matrices<a name="1"></a></h2><p>Toby Driscoll, July 2014</p><pre class="codeinput">clear, close <span class="string">all</span>
</pre><p>Suppose we want to construct the <span class="MathJax_Preview"><img src="morning1_eq68137.png" alt="$n\times n$"></span><script type="math/tex">n\times n</script> matrix whose <span class="MathJax_Preview"><img src="morning1_eq32240.png" alt="$(i,j)$"></span><script type="math/tex">(i,j)</script> entry is 1 if <span class="MathJax_Preview"><img src="morning1_eq73220.png" alt="$i=j$"></span><script type="math/tex">i=j</script>, <span class="MathJax_Preview"><img src="morning1_eq82919.png" alt="$-2$"></span><script type="math/tex">-2</script> if <span class="MathJax_Preview"><img src="morning1_eq61067.png" alt="$|i-j|=1$"></span><script type="math/tex">|i-j|=1</script>, and zero otherwise.</p><p>We're always free to type in the elements one by one.</p><pre class="codeinput">A = [ 1 -2 0 0 0 0 0;
      0 1 -2 1 0 0 0;
      0 0 1 -2 1 0 0;
      0 0 0 1 -2 1 0;
      0 0 0 0 1 -2 1;
      0 0 0 0 0 1 -2 ]
</pre><pre class="codeoutput">
A =

     1    -2     0     0     0     0     0
     0     1    -2     1     0     0     0
     0     0     1    -2     1     0     0
     0     0     0     1    -2     1     0
     0     0     0     0     1    -2     1
     0     0     0     0     0     1    -2

</pre><p>What a drag. And what if <span class="MathJax_Preview"><img src="morning1_eq53139.png" alt="$n=1000$"></span><script type="math/tex">n=1000</script>...?</p><h2>Loops<a name="5"></a></h2><p>Here's an easy method for any size, using a pair of nested loops.</p><pre class="codeinput">n = 7;
<span class="keyword">for</span> i = 1:n
    <span class="keyword">for</span> j = 1:n
        <span class="keyword">if</span> i==j
            A(i,j) = 1;
        <span class="keyword">elseif</span> abs(i-j)==1
            A(i,j) = -2;
        <span class="keyword">else</span>
            A(i,j) = 0;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
A
</pre><pre class="codeoutput">
A =

     1    -2     0     0     0     0     0
    -2     1    -2     0     0     0     0
     0    -2     1    -2     0     0     0
     0     0    -2     1    -2     0     0
     0     0     0    -2     1    -2     0
     0     0     0     0    -2     1    -2
     0     0     0     0     0    -2     1

</pre><p>That's straightforward but not exactly compact. You could do better in this case with just one loop, filling in just the nonzeros.</p><pre class="codeinput">n = 7;
A = zeros(n);   <span class="comment">% start with all zero n by n</span>
A(1,1) = 1;  A(1,2) = -2;
<span class="keyword">for</span> i = 2:n-1
    A(i,i) = 1;
    A(i,i-1) = -2;
    A(i,i+1) = -2;
<span class="keyword">end</span>
A(n,n-1) = -2;  A(n,n) = 1;
A
</pre><pre class="codeoutput">
A =

     1    -2     0     0     0     0     0
    -2     1    -2     0     0     0     0
     0    -2     1    -2     0     0     0
     0     0    -2     1    -2     0     0
     0     0     0    -2     1    -2     0
     0     0     0     0    -2     1    -2
     0     0     0     0     0    -2     1

</pre><p>We could even shorten the lines inside the loop to <tt>A(i,i-1:i+1)=[-2,1,-2]</tt>.</p><h2>No loops<a name="8"></a></h2><p>Note, however, that <span class="MathJax_Preview"><img src="morning1_eq31461.png" alt="$A$"></span><script type="math/tex">A</script> is easily described in terms of its diagonals. By using the <tt>diag</tt> command, it's easy to construct it with no loops at all.</p><pre class="codeinput">A = diag(ones(1,n)) + diag(-2*ones(1,n-1),1) + diag(-2*ones(1,n-1),-1)
</pre><pre class="codeoutput">
A =

     1    -2     0     0     0     0     0
    -2     1    -2     0     0     0     0
     0    -2     1    -2     0     0     0
     0     0    -2     1    -2     0     0
     0     0     0    -2     1    -2     0
     0     0     0     0    -2     1    -2
     0     0     0     0     0    -2     1

</pre><p>Easiest of all is if you know that a matrix defined by <span class="MathJax_Preview"><img src="morning1_eq54754.png" alt="$a_{i,j}=a_{i-j}$"></span><script type="math/tex">a_{i,j}=a_{i-j}</script> is called a Toeplitz matrix, and there is a command for building them.</p><pre class="codeinput">A = toeplitz( [1 -2 zeros(1,n-2) ] )
</pre><pre class="codeoutput">
A =

     1    -2     0     0     0     0     0
    -2     1    -2     0     0     0     0
     0    -2     1    -2     0     0     0
     0     0    -2     1    -2     0     0
     0     0     0    -2     1    -2     0
     0     0     0     0    -2     1    -2
     0     0     0     0     0    -2     1

</pre><h2>Other 'atomic' operations<a name="10"></a></h2><p>In addition to <tt>zeros</tt>, <tt>diag</tt>, and <tt>toeplitz</tt>, there are other commands to make common matrix building blocks without loops.</p><pre class="codeinput">I = eye(5)
J = ones(5)
</pre><pre class="codeoutput">
I =

     1     0     0     0     0
     0     1     0     0     0
     0     0     1     0     0
     0     0     0     1     0
     0     0     0     0     1


J =

     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1
     1     1     1     1     1

</pre><pre class="codeinput">U = triu(J)
L = tril(J,1)
</pre><pre class="codeoutput">
U =

     1     1     1     1     1
     0     1     1     1     1
     0     0     1     1     1
     0     0     0     1     1
     0     0     0     0     1


L =

     1     1     0     0     0
     1     1     1     0     0
     1     1     1     1     0
     1     1     1     1     1
     1     1     1     1     1

</pre><pre class="codeinput">R = rand(5)      <span class="comment">% uniform random in [0,1]</span>
N = randn(5)     <span class="comment">% normal random</span>
</pre><pre class="codeoutput">
R =

    0.1622    0.6020    0.4505    0.8258    0.1067
    0.7943    0.2630    0.0838    0.5383    0.9619
    0.3112    0.6541    0.2290    0.9961    0.0046
    0.5285    0.6892    0.9133    0.0782    0.7749
    0.1656    0.7482    0.1524    0.4427    0.8173


N =

    1.3790   -0.2779   -1.5771    1.1275   -1.7502
   -1.0582    0.7015    0.5080    0.3502   -0.2857
   -0.4686   -2.0518    0.2820   -0.2991   -0.8314
   -0.2725   -0.3538    0.0335    0.0229   -0.9792
    1.0984   -0.8236   -1.3337   -0.2620   -1.1564

</pre><pre class="codeinput">x = 0:0.2:1             <span class="comment">% equally spaced with given spacing</span>
y = linspace(0,1,6)     <span class="comment">% equally spaced with given number</span>
</pre><pre class="codeoutput">
x =

         0    0.2000    0.4000    0.6000    0.8000    1.0000


y =

         0    0.2000    0.4000    0.6000    0.8000    1.0000

</pre><pre class="codeinput">xtrans = x'             <span class="comment">% transpose</span>
</pre><pre class="codeoutput">
xtrans =

         0
    0.2000
    0.4000
    0.6000
    0.8000
    1.0000

</pre><pre class="codeinput">R = repmat(x',[1 3])    <span class="comment">% copy some matrix over and over</span>
</pre><pre class="codeoutput">
R =

         0         0         0
    0.2000    0.2000    0.2000
    0.4000    0.4000    0.4000
    0.6000    0.6000    0.6000
    0.8000    0.8000    0.8000
    1.0000    1.0000    1.0000

</pre><h2>Indexing<a name="16"></a></h2><p>The rows and columns of a matrix can be selected either by "direct" reference to the desired indices, or by "logical" indexes.</p><pre class="codeinput">A = magic(4)
</pre><pre class="codeoutput">
A =

    16     2     3    13
     5    11    10     8
     9     7     6    12
     4    14    15     1

</pre><pre class="codeinput">rows2and3 = A(2:3,:)
lastColumn = A(:,end)
oddRowsInColumn2 = A( logical([1 0 1 0]), 2 )
</pre><pre class="codeoutput">
rows2and3 =

     5    11    10     8
     9     7     6    12


lastColumn =

    13
     8
    12
     1


oddRowsInColumn2 =

     2
     7

</pre><p>In addition, every matrix is really stored as a linearly addressed block of memory. You can use a linear index instead.</p><pre class="codeinput">first7 = A( 1:7 )
biggerThan6 = A( A&gt;6 )
</pre><pre class="codeoutput">
first7 =

    16     5     9     4     2    11     7


biggerThan6 =

    16
     9
    11
     7
    14
    10
    15
    13
     8
    12

</pre><p>You can explicitly reshape a matrix as long as the number of elements doesn't change.</p><pre class="codeinput">twoByEight = reshape(A,[2 8])
vectorForm = reshape(A,[numel(A) 1])
</pre><pre class="codeoutput">
twoByEight =

    16     9     2     7     3     6    13    12
     5     4    11    14    10    15     8     1


vectorForm =

    16
     5
     9
     4
     2
    11
     7
    14
     3
    10
     6
    15
    13
     8
    12
     1

</pre><p>The last statement is also found by using <tt>A(:)</tt>.</p><p>Note that assignment is also possible with the same syntax.</p><pre class="codeinput">A([2 3],:) = A([3 2],:)   <span class="comment">% swap rows</span>
</pre><pre class="codeoutput">
A =

    16     2     3    13
     9     7     6    12
     5    11    10     8
     4    14    15     1

</pre><pre class="codeinput">A( A&lt;5 ) = NaN;    <span class="comment">% assign scalar to each</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 8.1<br></p></div><!--
##### SOURCE BEGIN #####
%% Making matrices
% Toby Driscoll, July 2014
clear, close all

%% 
% Suppose we want to construct the $n\times n$ matrix whose $(i,j)$ entry
% is 1 if $i=j$, $-2$ if $|i-j|=1$, and zero otherwise. 
%%
% We're always free to type in the elements one by one.
A = [ 1 -2 0 0 0 0 0;
      0 1 -2 1 0 0 0;
      0 0 1 -2 1 0 0;
      0 0 0 1 -2 1 0;
      0 0 0 0 1 -2 1;
      0 0 0 0 0 1 -2 ]
  
%%
% What a drag. And what if $n=1000$...?

%% Loops
% Here's an easy method for any size, using a pair of nested loops.
n = 7;
for i = 1:n
    for j = 1:n
        if i==j
            A(i,j) = 1;
        elseif abs(i-j)==1
            A(i,j) = -2;
        else
            A(i,j) = 0;
        end
    end
end
A

%%
% That's straightforward but not exactly compact. You could do better in
% this case with just one loop, filling in just the nonzeros. 
n = 7;
A = zeros(n);   % start with all zero n by n
A(1,1) = 1;  A(1,2) = -2;
for i = 2:n-1
    A(i,i) = 1;
    A(i,i-1) = -2;
    A(i,i+1) = -2;
end
A(n,n-1) = -2;  A(n,n) = 1;
A

%%
% We could even shorten the lines inside the loop to
% |A(i,i-1:i+1)=[-2,1,-2]|. 

%% No loops
% Note, however, that $A$ is easily described in terms of its diagonals. By
% using the |diag| command, it's easy to construct it with no loops at
% all.
A = diag(ones(1,n)) + diag(-2*ones(1,n-1),1) + diag(-2*ones(1,n-1),-1)

%%
% Easiest of all is if you know that a matrix defined by
% $a_{i,j}=a_{i-j}$ is called a Toeplitz matrix, and there is a command for
% building them. 
A = toeplitz( [1 -2 zeros(1,n-2) ] )

%% Other 'atomic' operations
% In addition to |zeros|, |diag|, and |toeplitz|, there are other commands
% to make common matrix building blocks without loops.
I = eye(5)
J = ones(5)

%%
U = triu(J)
L = tril(J,1)

%%
R = rand(5)      % uniform random in [0,1]
N = randn(5)     % normal random

%%
x = 0:0.2:1             % equally spaced with given spacing
y = linspace(0,1,6)     % equally spaced with given number

%%
xtrans = x'             % transpose

%%
R = repmat(x',[1 3])    % copy some matrix over and over


%% Indexing
% The rows and columns of a matrix can be selected either by "direct"
% reference to the desired indices, or by "logical" indexes. 
A = magic(4)

%%
rows2and3 = A(2:3,:)
lastColumn = A(:,end)
oddRowsInColumn2 = A( logical([1 0 1 0]), 2 )

%%
% In addition, every matrix is really stored as a linearly addressed block
% of memory. You can use a linear index instead.
first7 = A( 1:7 )
biggerThan6 = A( A>6 )

%%
% You can explicitly reshape a matrix as long as the number of elements
% doesn't change. 
twoByEight = reshape(A,[2 8])
vectorForm = reshape(A,[numel(A) 1])

%%
% The last statement is also found by using |A(:)|. 

%%
% Note that assignment is also possible with the same syntax.
A([2 3],:) = A([3 2],:)   % swap rows

%%
A( A<5 ) = NaN;    % assign scalar to each





##### SOURCE END #####
--></body></html>